#+TITLE: Sistema de adquisición de datos y lógica digital base para implementación en CubeSats
#+AUTHOR: A. Riedinger & G. Garcia

* ÍNDICE :toc:
- [[#sobre-el-proyecto][SOBRE EL PROYECTO]]
- [[#estructura-y-reglas][ESTRUCTURA Y REGLAS]]
- [[#satdac][SATDAC]]
  - [[#librerias][LIBRERIAS]]
  - [[#definiciones][DEFINICIONES]]
  - [[#main][MAIN]]
  - [[#interrupciones][INTERRUPCIONES]]
  - [[#funciones-locales][FUNCIONES LOCALES]]
- [[#erdytc][ERDYTC:]]
  - [[#librerias-1][LIBRERIAS]]
  - [[#definiciones-1][DEFINICIONES]]
  - [[#main-1][MAIN]]
  - [[#interrupciones-1][INTERRUPCIONES]]
  - [[#funciones-locales-1][FUNCIONES LOCALES]]

* SOBRE EL PROYECTO

El objetivo del proyecto es construir la base lógica digital inicial, como *prueba de concepto*, para aplicación en un CubeSat.

CubeSat es un estándar de diseño de nanosatélites, cuya estructura es escalable en cubos de 10 cm de arista y masa inferior a 1,33 kg. La premisa de este trabajo se basa en el diseño de un sistema de adquisición y transmisión de datos según el MCU STM32F4-BlackPill y en una estación de recepción de datos y transmisión de comandos según el MCU STM32F429ZI.

Esto es, el proyecto se divide en dos sistemas que trabajan de forma codependiente pero que son controlados por microcontroladores distintos:

 + Uno es el SATDAC (Sistema de Adquisicón y Transmisión de Datos Autosuficiente y Controlable), que estaría ubicado dentro del hipotético CubeSat.
 + Otro es el ERDYTC (Estación de Recepción de Datos Y Transmisión de Comandos), que se encontraría fuera del CubeSat.

El SATDAC posee las siguientes capacidades:

 + Sensado de temperatura.
 + Control y despliegue de periféricos por comando.
 + Recepción y transmisión de datos por RF.

Y la ERDYTC las siguientes:

 + Capacidad para mostrar datos recibidos y estados en LCD.
 + Ingreso de comandos por usuario y transmisión de los mismos.
 + Almacenamiento en memoria externa.
 + Recepción y transmisión de datos por RF.
* ESTRUCTURA Y REGLAS

El sistema completo contará con dos codigos interdependientes, pero que se cargan a MCU distintos. Se identifican como SATDAC (cargado a BlackPill según /code//satdac//src//main.c/) y ERDYTC (cargado a NUCLEO según /code//erdytc//src//main.c/)). La edición de los archivos se realizó en Doom Emacs y se utilizó la herramienta de ST Atollic TRUEStudio para cargar los códigos a los MCU y para debuggear.

En ambos códigos, se describe paso a paso las líneas y decisiones tomadas. Se siguen los siguientes pasos en la estructura:

 + Se describen las librerías a utilizar en cada caso.
 + Se definen estructuras utilizadas en la configuración de componentes o pines del MCU.
 + Se definen constantes utilizadas en el código.
 + Se declaran las funciones locales utilizadas.
 + Se inicializan las determinadas componentes y pines dentro del */main/*.
 + Se desarrollan las interrupciones configuradas.
 + Se desarrollan las funciones locales declaradas al inicio.

Para la síntesis del código se utilizan las siguientes reglas:

 + Funciones creadas por el usuario se identifican en mayúsculas. Ej.: *MY_FUNCTION()*.
 + Variables globales o definiciones creadas por el usuario se identifican en minúsculas. Ej.: *myGlobalVar = x*.
 + Variables locales creadas por el usuario se identifican con la primer letra en mayúscula y el resto en minúsculas. Ej.: *MyLocalVar = x*.
 + Variables o definiciones que identifican pines de la placa se describen con un guión bajo al inicio. Ej.: *_led = GPIO_Pin_x*.
 + Variables o definiciones que identifican puertos de la placa se describen con un guión bajo al inicio y la primer letra en mayúsculas. Ej.: *_Led = GPIOx*.
 + Variables o definiciones que identifican pinSources se describen con dos guiones bajos al inicio. Ej.: *__led = GPIO_PinSourcex*.

* SATDAC
:PROPERTIES:
:header-args: :tangle satdac/src/main.c
:END:

Aquí realizar una descripción más detallada del SATDAC, poner fotos de placas, prototipo físico terminado, etc.

** LIBRERIAS

En el proyecto se utilizan las siguientes librerías:

 + *Librerías estándar:* contienen las funciones y códigos básicos para microcontroladores STM32F4XX. Esto incluye todas las funciones para cambiar estados de puertos (/GPIO_Set_Bit()/, etc.) y las específicas como de definición de estructuras.
 + *Control del clock:* contiene las funciones relacionadas al control del clock del MCU, como por ejemplo /RCC_AHB1PeriphClockCmd()/ y demás.
 + *Control de pines analógicos:* contiene las funciones necesarias para configurar determinados como analógicos.
   + *RECORDAR*: los pines configurados como analógicos *NO PUEDEN RECIBIR UN VOLTAJE MAYOR A 3 V*.
 + *Control de timers:* incluye las funciones /TIM_*()/ necesarias para la configuración de timers del MCU.
 + *Matemáticas:* incluye funciones para realizar operaciones matemáticas básicas en /C/, como sea /pow()/ y demás.

#+begin_src c
/*----------------------------------------------------------------*/
/*LIBRERIAS:                                                      */
/*----------------------------------------------------------------*/
/*Librerias estandar:*/
#include "stm32f4xx.h"
#include "stm32f4xx_gpio.h"
#include "stdio.h"
#include "misc.h"

/*Control del clock:*/
#include "stm32f4xx_rcc.h"

/*Control de pines analogicos*/
#include "stm32f4xx_adc.h"

/*Control de timers:*/
#include "stm32f4xx_tim.h"

/*Matematicas:*/
#include "math.h"
#+end_src

** DEFINICIONES

En esta sección se declaran diferentes parámetros con valores fijos que se utilizarán luego a lo largo del código. El propósito de esto yace en independizar los valores abstractos y en su lugar utilizar nombres que ayuden a la interpretación del código.

#+begin_src c
/*----------------------------------------------------------------*/
/*DEFINICIONES:                                                   */
/*----------------------------------------------------------------*/
#+end_src

*** ESTRUCTURAS

En esta sección se declaran las diferentes estructuras utilizadas para la configuración de pines del MCU:

 + *General:* son estructuras genéricas que se utilzan para la configuración de aplicaciones básicas del MCU. Estas son:
   + Configuración de pines como salidas digitales.
   + Habilitacion de interrupciones.
   + Configuración de interrupciones externas.
 + *ADC:* utilizadas para la inicialización de pines como convertores analógico/digital.
 + *TIMERS:* utilizadas en la configuración de timers del MCU.
 + *DMA:* utilizadas para la habilitación del /Acceso Directo a Memoria/.

#+begin_src c
/* * * * * * * * * * * * * ESTRUCTURAS * * * * * * * * * * * * */
/*General:*/
GPIO_InitTypeDef        GPIO_InitStructure;
NVIC_InitTypeDef        NVIC_InitStructure;
EXTI_InitTypeDef        EXTI_InitStructure;

/*ADC:*/
ADC_InitTypeDef         ADC_InitStructure;
ADC_CommonInitTypeDef   ADC_CommonInitStructure;

/*TIMERS*/
TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
TIM_OCInitTypeDef       TIM_OCInitStructure;

/*DMA*/
DMA_InitTypeDef         DMA_InitStructure;
#+end_src

*** CONSTANTES

Aquí se declaran diferentes parámetros, que pueden tanto ser los puertos y pines que se utilizan en el hardware, como variables que poseen un valor fijo:

 + *Hardware:* se definen los pines en los que se conectan los elementos de hardware del sistema. Estos son:
   + *Servomotor:* conectado en el pin PA3.
 + *Parámetros:* se definen variables de valor fijo que se utilizarán adelante en el código. Estas son:
   + *Frecuencia PWM:* utilizada para el control del servomotor; su valor DEBE ser dado en Herzios (/Hz/).
   + *Ciclo de trabajo PWM:* define el duty cycle de la onda de salida PWM para controlar el servomotor.

#+begin_src c
/* * * * * * * * * * * * * CONSTANTES * * * * * * * * * * * * */
/* - - - - HARDWARE - - - -*/
/*Servomotor:*/
#define _Servo      GPIOA
#define _servo      GPIO_Pin_3
#define __servo     GPIO_PinSource3

/* - - - - PARAMS. - - - -*/
/*Frecuencia PWM:*/
#define freqPWM 10e3

/*Ciclo de trabajo PWM:*/
#define dutyCyclePWM 50
#+end_src

*** FUNCIONES LOCALES

En esta sección se definen los encabezados de las distintas funciones a utilizar en el código local:

 + *Inicialización TIM3:* función para incializar el TIM3 del MCU con una determinada frecuencia.
   + *Returns*: void.
   + *Params* : freq - Frecuencia en /[Hz]/ a la que se inicializará el TIM3.
 + *Inicialización TIM4:* función para inicializar el TIM4 para el control de la salida PWM necesaria para el control del servomotor.
   + *Returns*: void.
   + *Params* : void.
 + *Inicialización PWM:* función para inicializar las salidas PWM4.
   + *Returns*: void.
   + *Params* : void.
 + *Inicialización servo:* Función para inicializar la salida del servomotor como PWM:
   + *Returns*: void.
   + *Params* : void.
 + *Mover servo:* Función para iniciar el proceso de movimiento del servomotor.
   + *Returns*: void.
   + *Params* : void.

#+begin_src c
/* * * * * * * * * * * * * FUNCIONES * * * * * * * * * * * * */
/*Inicializacion TIM3:*/
void INIT_TIM3(uint32_t freq);

/*Inicializacion TIM4:*/
void INIT_TIMPWM(void);

/*Inicializacion PWM:*/
void INIT_PWM(void);

/*Inicializacion servo:*/
void INIT_SERVO(void);

/*Mover servo:*/
void MOVE_SERVO(void);
#+end_src

** MAIN

En esta parte se encuentra la sección principal del código donde se inicializa y se llama a las funciones. Además, se realizan diferentes procesamientos en el bucle principal.

#+begin_src c
/*----------------------------------------------------------------*/
/*MAIN:                                                           */
/*----------------------------------------------------------------*/
int main(void){
#+end_src

*** INICIALIZACION

En esta sección se inicializan las diferentes componentes del código. Este el procesamiento inicial que se realiza cuando se enciende el sistema.

Las funciones llamadas para inicializar son las siguientes:
 + *Inicio del sistema:* función general de las librerías estándar para inicializar las funciones del MCU.
 + *Inicialización de timers:* se llama a las funciones de inicialización de timers descritas en la sección de definciones. Estas son:
   + Inicialización del TIM3.
   + Inicialización del TIM4.
   + Inicialización del PWM.
 + *Servomotor:* se inicializan las funciones relacionadas al manejo del servomotor. Estas son:
   + Inicialización de la salida del servo.

#+begin_src c
/* * * * * * * * * * * * * INICIALIZ. * * * * * * * * * * * * */
    /*Inicio del sistema:*/
    SystemInit();

    /*Inicializacion de timers:*/
    INIT_TIMPWM();
    INIT_PWM();

    /*Servomotor:*/
    INIT_SERVO();
#+end_src

*** BUCLE PPAL.:

Esta sección muestra el bucle principal infinito del código:

#+begin_src c
/* * * * * * * * * * * * * BUCLE PPAL. * * * * * * * * * * * * */
  while (1)
  {
  }
}
#+end_src
** INTERRUPCIONES
** FUNCIONES LOCALES

En esta sección se implementan las diferentes funciones del código.

#+begin_src c
/*----------------------------------------------------------------*/
/*FUNCIONES LOCALES:                                              */
/*----------------------------------------------------------------*/
#+end_src

*** TIMERS:
**** TIM4:
Este es el TIMER utilizado para el control de la salida PWM.
***** Inicialización del TIMER:
Aquí se inicializa el TIMER para setear la frecuencia inicial del PWM.

El primer paso se basa en la habilitación del clock para el TIM4; el cual está conectado al bus APB1.

Luego, como se quiere que la frecuencia del TIM sea la máxima, se seteará el prescaler en cero. Esto es debido a que la frecuencia de tick del TIM está definida como:

 + TIM_tickFreq = TIM_defaultFreq / (prescaller_set + 1)

De esta forma, se garantiza que TIM_tickFreq = TIM_defaultFreq.

Ahora, para setear el periodo del TIM cuando se resetea, primero se debe obtener el valor máximo para el timer. En este caso, como el TIM es de 16 bits, el valor máximo será 2^16 = 65535.

Para obtener la frecuencia del PWM, la ecuación es:

 + PWM_freq = TIM_tickFreq / (TIM_period + 1)
 + TIM_period = TIM_tickFreq / PWM_freq - 1

Finalmente, se terminan de inicializar los restantes parámetros y se carga la inicialización en la estructura del timer para dar comienzo al conteo.

#+begin_src c
void INIT_TIMPWM(void){
    /*Declaracion estructura particular:*/
    TIM_TimeBaseInitTypeDef TIM_BaseStruct;

    /*Activacion del clock:*/
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);

    /*Seteo del preescaler en 0 para obtener la maxima frecuencia:*/
    TIM_BaseStruct.TIM_Prescaler = 0;

    /*Seteo del conteo hacia arriba:*/
    TIM_BaseStruct.TIM_CounterMode = TIM_CounterMode_Up;

    /*Calculo periodo:*/
    TIM_BaseStruct.TIM_Period = SystemCoreClock / freqPWM - 1;

    /*Seteo de parametros restantes y carga a la estructura:*/
    TIM_BaseStruct.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_BaseStruct.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM4, &TIM_BaseStruct);

    /*Inicio del conteo:*/
    TIM_Cmd(TIM4, ENABLE);
}
#+end_src
***** Inicialización de las salidas PWM4:

Esta función setea los canales PWM a las salidas PWM del servo.

Primero, se setea el PWM en modo 2, lo que indica que la señal se generará comenzando en estado bajo. Luego, se habilitan las salidas PWM y se indica la polaridad.

Ahora, para calcular el duty cycle de la señal:

 + pulseLength = ((TIM_Period + 1)*dutyCyclePWM) / 100 - 1

donde dutyCycle está en porcentaje, entre 0% y 100%.

Por tanto, se crea una variable para calcular el periódo de trabajo del TIM4, llamada *Period*. Y entonces a partir de la misma se puede establecer el duty cycle del PWM.

Finalmente se carga la incialización a la estructura y se activa la salida.

#+begin_src c
void INIT_PWM(void){
    TIM_OCInitTypeDef TIM_OCStruct;

    TIM_OCStruct.TIM_OCMode = TIM_OCMode_PWM2;
    TIM_OCStruct.TIM_OutputState = TIM_OutputState_Enable;
    TIM_OCStruct.TIM_OCPolarity = TIM_OCPolarity_Low;

    uint32_t Period= SystemCoreClock / freqPWM - 1;

    TIM_OCStruct.TIM_Pulse = ((Period + 1) * dutyCyclePWM) / 100 - 1;

    TIM_OC1Init(TIM4, &TIM_OCStruct);
    TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Enable);
}
#+end_src
*** Servomotor:

Aquí se describen las funciones relacionadas con el funcionamiento del servomotor.

**** Inicialización:

Esta función inicializa la salida correspondiente al servo con soporte para PWM disparado según el TIM4.

Se comienza habilitando el clock para el puerto donde estará la salida PWM (GPIOA - Pin 3). Configuración de la función alternante PWM disparada por el TIM4 para el pin correspondiente al servo.

Se setea el pin finalmente y se carga en la estructura.

#+begin_src c
void INIT_SERVO(void){
    GPIO_InitTypeDef GPIO_InitStruct;

    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);

    GPIO_PinAFConfig(_Servo, __servo, GPIO_AF_TIM4);

    GPIO_InitStruct.GPIO_Pin = _servo;
    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_100MHz;
    GPIO_Init(GPIOD, &GPIO_InitStruct);
}
#+end_src
* ERDYTC:
:PROPERTIES:
:header-args: :tangle erdytc/src/main.c
:END:

Aquí realizar una descripción más detallada del sistema, poner fotos de placas, prototipo físico terminado, etc.

** LIBRERIAS

En el proyecto se utilizan las siguientes librerías:

 + *Librerías estándar:* contienen las funciones y códigos básicos para microcontroladores STM32F4XX. Esto incluye todas las funciones para cambiar estados de puertos (/GPIO_Set_Bit()/, etc.) y las específicas como de definición de estructuras.
 + *Control del clock:* contiene las funciones relacionadas al control del clock del MCU, como por ejemplo /RCC_AHB1PeriphClockCmd()/ y demás.
 + *Control de timers:* incluye las funciones /TIM_*()/ necesarias para la configuración de timers del MCU.
 + *Matemáticas:* incluye funciones para realizar operaciones matemáticas básicas en /C/, como sea /pow()/ y demás.

#+begin_src c
/*----------------------------------------------------------------*/
/*LIBRERIAS:                                                      */
/*----------------------------------------------------------------*/
/*Librerias estandar:*/
#include "stm32f4xx.h"
#include "stm32f4xx_gpio.h"
#include "stdio.h"
#include "misc.h"

/*Control del clock:*/
#include "stm32f4xx_rcc.h"

/*Control de timers:*/
#include "stm32f4xx_tim.h"

/*Matematicas:*/
#include "math.h"
#+end_src

** DEFINICIONES

En esta sección se declaran diferentes parámetros con valores fijos que se utilizarán luego a lo largo del código. El propósito de esto yace en independizar los valores abstractos y en su lugar utilizar nombres que ayuden a la interpretación del código.

#+begin_src c
/*----------------------------------------------------------------*/
/*DEFINICIONES:                                                   */
/*----------------------------------------------------------------*/
#+end_src

*** ESTRUCTURAS

En esta sección se declaran las diferentes estructuras utilizadas para la configuración de pines del MCU:

 + *General:* son estructuras genéricas que se utilzan para la configuración de aplicaciones básicas del MCU. Estas son:
   + Configuración de pines como salidas digitales.
   + Habilitacion de interrupciones.
   + Configuración de interrupciones externas.
 + *TIMERS:* utilizadas en la configuración de timers del MCU.
 + *DMA:* utilizadas para la habilitación del /Acceso Directo a Memoria/.

#+begin_src c
/* * * * * * * * * * * * * ESTRUCTURAS * * * * * * * * * * * * */
/*General:*/
GPIO_InitTypeDef        GPIO_InitStructure;
NVIC_InitTypeDef        NVIC_InitStructure;
EXTI_InitTypeDef        EXTI_InitStructure;

/*TIMERS*/
TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
TIM_OCInitTypeDef       TIM_OCInitStructure;

/*DMA*/
DMA_InitTypeDef         DMA_InitStructure;
#+end_src

*** CONSTANTES

Aquí se declaran diferentes parámetros, que pueden tanto ser los puertos y pines que se utilizan en el hardware, como variables que poseen un valor fijo:

 + *LCD:* se definen variables de valor fijo, constantes y estructuras que se utilizan en las funciones de manejo del LCD. Estas son:
   + *Constantes varias:* utilizadas para reemplazar determinados valores en las funciones del LCD.
   + *Identificación pines:* estructura que se utiliza para nombrar a los pines del LCD en la definición del mismo.
   + *Nombre LCD:* se define el nombre del LCD como una constante.
   + *Estados LCD:* estructura utilizada para distinguir los distinto estados del LCD.
   + *Crear LCD:* estructura utilizada para crear el objeto LCD sobre el cuál se aplicarán las funciones.

 + *Hardware:* se definen los pines en los que se conectan los elementos de hardware del sistema. Estos son:
   + *LCD:* pines conectados según:

     |------+------+------+-----+------+------+------|
     | RS   | E    | D4   | D5  | D6   | D7   | BL   |
     |------+------+------+-----+------+------+------|
     | PE13 | PF15 | PF13 | PE9 | PE11 | PF14 | PG14 |
     |------+------+------+-----+------+------+------|

   + *Pulsadores:* conectados en los siguientes pines:

     |-----+-----+-----+-----|
     | F1  | F2  | C1  | C2  |
     |-----+-----+-----+-----|
     | PC9 | PB8 | PC6 | PC8 |
     |-----+-----+-----+-----|

 + *Parámetros:* se definen variables de valor fijo que se utilizarán adelante en el código. Estas son:

#+begin_src c
/* * * * * * * * * * * * * CONSTANTES * * * * * * * * * * * * */
/* - - - -   LCD   - - - -*/
/*Constantes varias:*/
#define  TLCD_INIT_PAUSE        100000
#define  TLCD_PAUSE             50000
#define  TLCD_CLK_PAUSE         1000
#define  TLCD_MAXX              16
#define  TLCD_MAXY              2
#define  MaxDigCount            4095
#define  MaxMiliVoltRef         3320
#define  Res32Bit               32
#define  DAC_DHR12R2_ADDRESS    0x40007414
#define  TLCD_CMD_INIT_DISPLAY  0x28
#define  TLCD_CMD_ENTRY_MODE    0x06
#define  TLCD_CMD_DISP_M0       0x08
#define  TLCD_CMD_DISP_M1       0x0C
#define  TLCD_CMD_DISP_M2       0x0E
#define  TLCD_CMD_DISP_M3       0x0F
#define  TLCD_CMD_CLEAR         0x01

/*Identificacion pines:*/
typedef enum
{
  TLCD_RS = 0,  // RS-Pin
  TLCD_E  = 1,  // E-Pin
  TLCD_D4 = 2,  // DB4-Pin
  TLCD_D5 = 3,  // DB5-Pin
  TLCD_D6 = 4,  // DB6-Pin
  TLCD_D7 = 5   // DB7-Pin
}TLCD_NAME_t;

/*Nombre LCD:*/
#define  TLCD_ANZ   6

/*Estados LCD:*/
typedef enum {
  TLCD_OFF = 0,
  TLCD_ON,
  TLCD_CURSOR,
  TLCD_BLINK
}TLCD_MODE_t;

/*Crear LCD:*/
typedef struct {
  TLCD_NAME_t TLCD_NAME;
  GPIO_TypeDef* TLCD_PORT;
  const uint16_t TLCD_PIN;
  const uint32_t TLCD_CLK;
  BitAction TLCD_INIT;
}LCD_2X16_t;

/* - - - - HARDWARE - - - -*/
/*Definicion de pines del LCD:*/
LCD_2X16_t LCD_2X16[] = {
    /* Name  , PORT ,     PIN    ,         CLOCK       ,   Init    */
    { TLCD_RS, GPIOE, GPIO_Pin_13, RCC_AHB1Periph_GPIOE, Bit_RESET },
    { TLCD_E,  GPIOF, GPIO_Pin_15, RCC_AHB1Periph_GPIOF, Bit_RESET },
    { TLCD_D4, GPIOF, GPIO_Pin_13, RCC_AHB1Periph_GPIOF, Bit_RESET },
    { TLCD_D5, GPIOE, GPIO_Pin_9,  RCC_AHB1Periph_GPIOE, Bit_RESET },
    { TLCD_D6, GPIOE, GPIO_Pin_11, RCC_AHB1Periph_GPIOE, Bit_RESET },
    { TLCD_D7, GPIOF, GPIO_Pin_14, RCC_AHB1Periph_GPIOF, Bit_RESET },};

/*Pulsadores:*/
#define _F1 GPIOC
#define _f1 GPIO_Pin_9
#define _F2 GPIOB
#define _f2 GPIO_Pin_8
#define _C1 GPIOC
#define _c1 GPIO_Pin_6
#define _C2 GPIOC
#define _c2 GPIO_Pin_8

/* - - - - PARAMS. - - - -*/

#+end_src

*** FUNCIONES LOCALES

En esta sección se definen los encabezados de las distintas funciones a utilizar en el código local:

 + *Parámetros LCD:* funciones utilizadas en el background para determinar varias cualidades del LCD. Son principalmente utilizadas por otras funciones para conseguir parámetros del LCD.
 + *Inicialización LCD:* función para inicializar los pines del LCD según el objeto /LCD_2X16/ definido a partir de los pines del hardware.
   + *Returns*: void.
   + *Params.*: Matriz tipo LCD_2X16_t con los pines detallados del LCD.
 + *Refrescar LCD:* función utilizada para reiniciar la pantalla del LCD. Normalmente se usa para actualizar los valores mostrados en pantalla.
   + *Returns*: void.
   + *Params.*: Matriz tipo LCD_2X16_t con los pines detallados del LCD.
 + *Imprimir LCD:* función utilizada para imprimir en el LCD una string introducida por el usuario.
   + *Returns*: void
   + *Params.*:
     + Matriz tipo LCD_2X16_t con los pines detallados del LCD.
     + Un indicador /x/ para indentificar la columna del LCD donde se iniciará la string.
     + Un indicardor /y/ para identificar la fila del LCD donde se iniciará la string.
     + Una string o puntero a la misma.
 + *Inicialización TIM3:* función para incializar el TIM3 del MCU con una determinada frecuencia.
   + *Returns*: void.
   + *Params* : freq - Frecuencia en /[Hz]/ a la que se inicializará el TIM3.
 + *Encontrar CLOCK:* función utilizada para definir el CLOCK correspondiente a un determinado puerto en las funciones.
   + *Returns*: /uint32_t/ con el dato del CLOCK.
   + *Params.*: Nombre del puerto a determinar.
 + *Configuración de interrupciones externas:* funciones utilizadas para habilitar las interrupciones externas; normalmente para interrumpir el MCU a través de entradas digitales.
   + *Inicialización EXTI:* se inicializa un pin del MCU para funcionar según la interrupción por entrada externa.
     + *Returns*: void.
     + *Params.*: Nombre del puerto y pin a configurar.
   + Las demás funciones **_EXTI_** se utilizan dentro de =INIT_EXTINT= para encontrar los parámetros correctos de los pines dados.

#+begin_src c
/* * * * * * * * * * * * * FUNCIONES * * * * * * * * * * * * */
/*Parametros LCD:*/
void P_LCD_2x16_InitIO(LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_PinLo(TLCD_NAME_t lcd_pin, LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_PinHi(TLCD_NAME_t lcd_pin, LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_Delay(volatile uint32_t nCount);
void P_LCD_2x16_InitSequenz(LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_Clk(LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_Cmd(uint8_t wert, LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_Cursor(LCD_2X16_t* LCD_2X16, uint8_t x, uint8_t y);
void P_LCD_2x16_Data(uint8_t wert, LCD_2X16_t* LCD_2X16);

/*Inicializacion LCD:*/
void INIT_LCD_2x16(LCD_2X16_t* LCD_2X16);

/*Refrescar LCD:*/
void CLEAR_LCD_2x16(LCD_2X16_t* LCD_2X16);

/*Imprimir LCD:*/
void PRINT_LCD_2x16(LCD_2X16_t* LCD_2X16, uint8_t x, uint8_t y, char *ptr);

/*Inicializacion TIM3:*/
void INIT_TIM3(uint32_t freq);

/*Configuracion de nterrupciones externas:*/
void INIT_EXTINT(GPIO_TypeDef* Port, uint16_t Pin);
uint8_t FIND_EXTI_PORT_SOURCE(GPIO_TypeDef* Port);
uint8_t FIND_EXTI_PIN_SOURCE(uint32_t Pin);
uint32_t FIND_EXTI_LINE(uint32_t Pin);
uint32_t FIND_EXTI_HANDLER(uint32_t Pin);

/*Encontrar CLOCK:*/
uint32_t FIND_CLOCK(GPIO_TypeDef* Port);
#+end_src

** MAIN

En esta parte se encuentra la sección principal del código donde se inicializa y se llama a las funciones. Además, se realizan diferentes procesamientos en el bucle principal.

#+begin_src c
/*----------------------------------------------------------------*/
/*MAIN:                                                           */
/*----------------------------------------------------------------*/
int main(void){
#+end_src

*** INICIALIZACION

En esta sección se inicializan las diferentes componentes del código. Este el procesamiento inicial que se realiza cuando se enciende el sistema.

Las funciones llamadas para inicializar son las siguientes:
 + *Inicio del sistema:* función general de las librerías estándar para inicializar las funciones del MCU.

#+begin_src c
/* * * * * * * * * * * * * INICIALIZ. * * * * * * * * * * * * */
    /*Inicio del sistema:*/
    SystemInit();
#+end_src

*** BUCLE PPAL.:

Esta sección muestra el bucle principal infinito del código:

#+begin_src c
/* * * * * * * * * * * * * BUCLE PPAL. * * * * * * * * * * * * */
  while (1)
  {
  }
}
#+end_src

** INTERRUPCIONES
** FUNCIONES LOCALES
En esta sección se implementan las diferentes funciones del código.

#+begin_src c
/*----------------------------------------------------------------*/
/*FUNCIONES LOCALES:                                              */
/*----------------------------------------------------------------*/
#+end_src
*** General
**** Encontrar CLOCK
#+begin_src c
uint32_t FIND_CLOCK(GPIO_TypeDef* Port)
{
    uint32_t Clock;

    if      (Port == GPIOA) Clock = RCC_AHB1Periph_GPIOA;
    else if (Port == GPIOB) Clock = RCC_AHB1Periph_GPIOB;
    else if (Port == GPIOC) Clock = RCC_AHB1Periph_GPIOC;
    else if (Port == GPIOD) Clock = RCC_AHB1Periph_GPIOD;
    else if (Port == GPIOE) Clock = RCC_AHB1Periph_GPIOE;
    else if (Port == GPIOF) Clock = RCC_AHB1Periph_GPIOF;
    else if (Port == GPIOG) Clock = RCC_AHB1Periph_GPIOG;
    return Clock;
}
#+end_src

*** LCD:

Primero se definen las funciones internas del LCD que se utilizan luego en las funciones activas. Estas son:

 + Inicialización de los pines del LCD.
 + Cambio de estados del LCD, para modificar un bit a alto o bajo.
 + Retardo del LCD, utilizado solamente en funciones específicas del LCD.
 + Inicialización secuencias LCD.
 + Configuración del CLOCK del LCD.
 + Definición de comandos del LCD.
 + Análisis de datos del LCD.

#+begin_src c
/* * * * * * * * * * * * *     LCD    * * * * * * * * * * * * */
/*Inicializacion pines LCD:*/
void P_LCD_2x16_InitIO(LCD_2X16_t* LCD_2X16)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    TLCD_NAME_t lcd_pin;

    for (lcd_pin = 0; lcd_pin < TLCD_ANZ; lcd_pin++)
    {
        //Habilitacion del Clock para cada PIN:
        RCC_AHB1PeriphClockCmd(LCD_2X16[lcd_pin].TLCD_CLK, ENABLE);

        //Configuracion como salidas digitales:
        GPIO_InitStructure.GPIO_Pin = LCD_2X16[lcd_pin].TLCD_PIN;
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
        GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
        GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
        GPIO_Init(LCD_2X16[lcd_pin].TLCD_PORT, &GPIO_InitStructure);

        //Default Wert einstellen
        if(LCD_2X16[lcd_pin].TLCD_INIT == Bit_RESET)
            P_LCD_2x16_PinLo(lcd_pin, LCD_2X16);
        else
            P_LCD_2x16_PinHi(lcd_pin, LCD_2X16);
    }
}

/*Cambio de estados del LCD:*/
void P_LCD_2x16_PinLo(TLCD_NAME_t lcd_pin, LCD_2X16_t* LCD_2X16)
{
  LCD_2X16[lcd_pin].TLCD_PORT->BSRRH = LCD_2X16[lcd_pin].TLCD_PIN;
}

void P_LCD_2x16_PinHi(TLCD_NAME_t lcd_pin, LCD_2X16_t* LCD_2X16)
{
  LCD_2X16[lcd_pin].TLCD_PORT->BSRRL = LCD_2X16[lcd_pin].TLCD_PIN;
}

/*Retardo LCD:*/
void P_LCD_2x16_Delay(volatile uint32_t nCount)
{
  while(nCount--)
  {
  }
}

/*Inicializacion secuencia LCD:*/
void P_LCD_2x16_InitSequenz(LCD_2X16_t* LCD_2X16)
{
  //Inicializacion de la secuencia:
  P_LCD_2x16_PinHi(TLCD_D4, LCD_2X16);
  P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16);
  P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  // Erster Init Impuls
  P_LCD_2x16_Clk(LCD_2X16);
  P_LCD_2x16_Delay(TLCD_PAUSE);
  // Zweiter Init Impuls
  P_LCD_2x16_Clk(LCD_2X16);
  P_LCD_2x16_Delay(TLCD_PAUSE);
  // Dritter Init Impuls
  P_LCD_2x16_Clk(LCD_2X16);
  P_LCD_2x16_Delay(TLCD_PAUSE);
  // LCD-Modus einstellen (4Bit-Mode)
  P_LCD_2x16_PinLo(TLCD_D4, LCD_2X16);
  P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16);
  P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  P_LCD_2x16_Clk(LCD_2X16);
  P_LCD_2x16_Delay(TLCD_PAUSE);
}

/*Configuracion CLOCK LCD:*/
void P_LCD_2x16_Clk(LCD_2X16_t* LCD_2X16)
{
  // Pin-E auf Hi
  P_LCD_2x16_PinHi(TLCD_E, LCD_2X16);
  // kleine Pause
  P_LCD_2x16_Delay(TLCD_CLK_PAUSE);
  // Pin-E auf Lo
  P_LCD_2x16_PinLo(TLCD_E, LCD_2X16);
  // kleine Pause
  P_LCD_2x16_Delay(TLCD_CLK_PAUSE);
}

/*Comandos LCD:*/
void P_LCD_2x16_Cmd(uint8_t wert, LCD_2X16_t* LCD_2X16)
{
  // RS=Lo (Command)
  P_LCD_2x16_PinLo(TLCD_RS, LCD_2X16);
  // Hi-Nibble ausgeben
  if((wert&0x80)!=0) P_LCD_2x16_PinHi(TLCD_D7, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  if((wert&0x40)!=0) P_LCD_2x16_PinHi(TLCD_D6, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  if((wert&0x20)!=0) P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D5, LCD_2X16);
  if((wert&0x10)!=0) P_LCD_2x16_PinHi(TLCD_D4, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D4, LCD_2X16);
  P_LCD_2x16_Clk(LCD_2X16);
  // Lo-Nibble ausgeben
  if((wert&0x08)!=0) P_LCD_2x16_PinHi(TLCD_D7, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  if((wert&0x04)!=0) P_LCD_2x16_PinHi(TLCD_D6, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  if((wert&0x02)!=0) P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D5, LCD_2X16);
  if((wert&0x01)!=0) P_LCD_2x16_PinHi(TLCD_D4, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D4, LCD_2X16);
  P_LCD_2x16_Clk(LCD_2X16);
}

void P_LCD_2x16_Cursor(LCD_2X16_t* LCD_2X16, uint8_t x, uint8_t y)
{
  uint8_t wert;

  if(x>=TLCD_MAXX) x=0;
  if(y>=TLCD_MAXY) y=0;

  wert=(y<<6);
  wert|=x;
  wert|=0x80;
  P_LCD_2x16_Cmd(wert,LCD_2X16);
}

/*Analisis de datos LCD:*/
void P_LCD_2x16_Data(uint8_t wert, LCD_2X16_t* LCD_2X16)
{
  // RS=Hi (Data)
  P_LCD_2x16_PinHi(TLCD_RS, LCD_2X16);
  // Hi-Nibble ausgeben
  if((wert&0x80)!=0) P_LCD_2x16_PinHi(TLCD_D7, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  if((wert&0x40)!=0) P_LCD_2x16_PinHi(TLCD_D6, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  if((wert&0x20)!=0) P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D5, LCD_2X16);
  if((wert&0x10)!=0) P_LCD_2x16_PinHi(TLCD_D4, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D4, LCD_2X16);
  P_LCD_2x16_Clk(LCD_2X16);
  // Lo-Nibble ausgeben
  if((wert&0x08)!=0) P_LCD_2x16_PinHi(TLCD_D7, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  if((wert&0x04)!=0) P_LCD_2x16_PinHi(TLCD_D6, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  if((wert&0x02)!=0) P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D5, LCD_2X16);
  if((wert&0x01)!=0) P_LCD_2x16_PinHi(TLCD_D4, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D4, LCD_2X16);
  P_LCD_2x16_Clk(LCD_2X16);
}
#+end_src

Luego, se definen las funciones activas que se utilizarán en la parte de funcionalidad del código. Estas son:

 + Incialización de los pines del LCD.
 + Refresco de la pantalla del LCD.
 + Impresión en la pantalla del LCD.

#+begin_src c
/*Inicializacion de los pines del LCD:*/
void INIT_LCD_2x16(LCD_2X16_t* LCD_2X16)
{
    //Inicialización de los pines del LCD:
    P_LCD_2x16_InitIO(LCD_2X16);
    // kleine Pause
    P_LCD_2x16_Delay(TLCD_INIT_PAUSE);
    // Init Sequenz starten
    P_LCD_2x16_InitSequenz(LCD_2X16);
    // LCD-Settings einstellen
    P_LCD_2x16_Cmd(TLCD_CMD_INIT_DISPLAY, LCD_2X16);
    P_LCD_2x16_Cmd(TLCD_CMD_ENTRY_MODE, LCD_2X16);
    // Display einschalten
    P_LCD_2x16_Cmd(TLCD_CMD_DISP_M1, LCD_2X16);
    // Display l�schen
    P_LCD_2x16_Cmd(TLCD_CMD_CLEAR, LCD_2X16);
    // kleine Pause
    P_LCD_2x16_Delay(TLCD_PAUSE);
}

/*Refresco de la pantalla del LCD:*/
void CLEAR_LCD_2x16(LCD_2X16_t* LCD_2X16)
{
  // Display l�schen
  P_LCD_2x16_Cmd(TLCD_CMD_CLEAR, LCD_2X16);
  // kleine Pause
  P_LCD_2x16_Delay(TLCD_PAUSE);
}

/*Impresion en la pantalla del LCD:*/
void PRINT_LCD_2x16(LCD_2X16_t* LCD_2X16, uint8_t x, uint8_t y, char *ptr)
{
  // Cursor setzen
  P_LCD_2x16_Cursor(LCD_2X16,x,y);
  // kompletten String ausgeben
  while (*ptr != 0) {
    P_LCD_2x16_Data(*ptr, LCD_2X16);
    ptr++;
  }
}
#+end_src
*** EXTI:
**** Habilitación de pin EXTI
#+begin_src c
void INIT_EXTINT(GPIO_TypeDef* Port, uint16_t Pin)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;

    /*Enable GPIO clock:*/
    uint32_t Clock;
    Clock = FIND_CLOCK(Port);
    RCC_AHB1PeriphClockCmd(Clock, ENABLE);
    /* Enable SYSCFG clock */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

    /* Configure pin as input floating */
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_Pin = Pin;
    GPIO_Init(Port, &GPIO_InitStructure);

    /* Connect EXTI Line to pin */
    SYSCFG_EXTILineConfig(FIND_EXTI_PORT_SOURCE(Port), FIND_EXTI_PIN_SOURCE(Pin));

    /* Configure EXTI Line0 */
    EXTI_InitStructure.EXTI_Line = FIND_EXTI_LINE(Pin);
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_Init(&EXTI_InitStructure);

    /* Enable and set EXTI Line0 Interrupt to the lowest priority */
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    NVIC_InitStructure.NVIC_IRQChannel = FIND_EXTI_HANDLER(Pin);
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x03;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x03;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}
#+end_src
**** Encontrar port source EXTI
#+begin_src c
uint8_t FIND_EXTI_PORT_SOURCE(GPIO_TypeDef* Port)
{
    if (Port == GPIOA)      return EXTI_PortSourceGPIOA;
    else if (Port == GPIOB) return EXTI_PortSourceGPIOB;
    else if (Port == GPIOC) return EXTI_PortSourceGPIOC;
    else if (Port == GPIOD) return EXTI_PortSourceGPIOD;
    else if (Port == GPIOE) return EXTI_PortSourceGPIOE;
    else if (Port == GPIOF) return EXTI_PortSourceGPIOF;
    else                    return 0;
}
#+end_src
**** Encontrar pin source EXTI
#+begin_src c
uint8_t FIND_EXTI_PIN_SOURCE(uint32_t Pin)
{
    if (Pin == GPIO_Pin_0)          return EXTI_PinSource0;
    else if (Pin == GPIO_Pin_1)     return EXTI_PinSource1;
    else if (Pin == GPIO_Pin_1)     return EXTI_PinSource1;
    else if (Pin == GPIO_Pin_2)     return EXTI_PinSource2;
    else if (Pin == GPIO_Pin_3)     return EXTI_PinSource3;
    else if (Pin == GPIO_Pin_4)     return EXTI_PinSource4;
    else if (Pin == GPIO_Pin_5)     return EXTI_PinSource5;
    else if (Pin == GPIO_Pin_6)     return EXTI_PinSource6;
    else if (Pin == GPIO_Pin_7)     return EXTI_PinSource7;
    else if (Pin == GPIO_Pin_8)     return EXTI_PinSource8;
    else if (Pin == GPIO_Pin_9)     return EXTI_PinSource9;
    else if (Pin == GPIO_Pin_10)    return EXTI_PinSource10;
    else if (Pin == GPIO_Pin_11)    return EXTI_PinSource11;
    else if (Pin == GPIO_Pin_12)    return EXTI_PinSource12;
    else if (Pin == GPIO_Pin_13)    return EXTI_PinSource13;
    else if (Pin == GPIO_Pin_14)    return EXTI_PinSource14;
    else                            return 0;
}
#+end_src
**** Encontrar EXTI line
#+begin_src c
uint32_t FIND_EXTI_LINE(uint32_t Pin)
{
    if (Pin == GPIO_Pin_0)          return EXTI_Line0;
    else if (Pin == GPIO_Pin_1)     return EXTI_Line1;
    else if (Pin == GPIO_Pin_2)     return EXTI_Line2;
    else if (Pin == GPIO_Pin_3)     return EXTI_Line3;
    else if (Pin == GPIO_Pin_4)     return EXTI_Line4;
    else if (Pin == GPIO_Pin_5)     return EXTI_Line5;
    else if (Pin == GPIO_Pin_6)     return EXTI_Line6;
    else if (Pin == GPIO_Pin_7)     return EXTI_Line7;
    else if (Pin == GPIO_Pin_8)     return EXTI_Line8;
    else if (Pin == GPIO_Pin_9)     return EXTI_Line9;
    else if (Pin == GPIO_Pin_10)    return EXTI_Line10;
    else if (Pin == GPIO_Pin_11)    return EXTI_Line11;
    else if (Pin == GPIO_Pin_12)    return EXTI_Line12;
    else if (Pin == GPIO_Pin_13)    return EXTI_Line13;
    else if (Pin == GPIO_Pin_14)    return EXTI_Line14;
    else if (Pin == GPIO_Pin_15)    return EXTI_Line15;
    else                            return 0;
}
#+end_src
**** Encontrar EXTI handler
#+begin_src c
uint32_t FIND_EXTI_HANDLER(uint32_t Pin)
{
    if (Pin == GPIO_Pin_0)          return EXTI0_IRQn;
    else if (Pin == GPIO_Pin_1)     return EXTI1_IRQn;
    else if (Pin == GPIO_Pin_2)     return EXTI2_IRQn;
    else if (Pin == GPIO_Pin_3)     return EXTI3_IRQn;
    else if (Pin == GPIO_Pin_4)     return EXTI4_IRQn;
    else if (Pin == GPIO_Pin_5  ||
             Pin == GPIO_Pin_5  ||
             Pin == GPIO_Pin_7  ||
             Pin == GPIO_Pin_8  ||
             Pin == GPIO_Pin_9)     return EXTI9_5_IRQn;
    else if (Pin == GPIO_Pin_10 ||
             Pin == GPIO_Pin_11 ||
             Pin == GPIO_Pin_12 ||
             Pin == GPIO_Pin_13 ||
             Pin == GPIO_Pin_14 ||
             Pin == GPIO_Pin_15)    return EXTI15_10_IRQn;
    else                            return 0;
}
#+end_src
