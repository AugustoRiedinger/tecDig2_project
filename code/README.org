#+TITLE: Sistema de adquisición de datos y lógica digital base para implementación en CubeSats
#+AUTHOR: A. Riedinger & G. Garcia

* Índice :toc:
- [[#sobre-el-proyecto][Sobre el proyecto:]]
- [[#estructura-del-código][Estructura del código:]]
- [[#satdac][SATDAC:]]
  - [[#librerias-utilizadas][Librerias utilizadas:]]
  - [[#estructuras][Estructuras:]]
  - [[#definición-de-constantes][Definición de constantes:]]
  - [[#definición-de-funciones-locales][Definición de funciones locales:]]
  - [[#main][Main:]]
  - [[#interrupciones][Interrupciones:]]
  - [[#funciones-locales][Funciones locales:]]
- [[#erdytc][ERDYTC:]]
  - [[#librerías-utilizadas][Librerías utilizadas:]]
  - [[#estructuras-1][Estructuras:]]
  - [[#definición-de-constantes-1][Definición de constantes:]]
  - [[#definición-de-funciones-locales-1][Definición de funciones locales:]]
  - [[#main-1][Main:]]
  - [[#interrupciones-1][Interrupciones:]]
  - [[#funciones-locales-1][Funciones locales:]]

* Sobre el proyecto:

El objetivo del proyecto es construir la base lógica digital inicial, como *prueba de concepto*, para aplicación en un CubeSat.

CubeSat es un estándar de diseño de nanosatélites, cuya estructura es escalable en cubos de 10 cm de arista y masa inferior a 1,33 kg. La premisa de este trabajo se basa en el diseño de un sistema de adquisición y transmisión de datos según el MCU STM32F4-BlackPill y en una estación de recepción de datos y transmisión de comandos según el MCU STM32F429ZI.

Esto es, el proyecto se divide en dos sistemas que trabajan de forma codependiente pero que son controlados por microcontroladores distintos:

 + Uno es el SATDAC (Sistema de Adquisicón y Transmisión de Datos Autosuficiente y Controlable), que estaría ubicado dentro del hipotético CubeSat.
 + Otro es el ERDYTC (Estación de Recepción de Datos Y Transmisión de Comandos), que se encontraría fuera del CubeSat.

El SATDAC posee las siguientes capacidades:

 + Sensado de temperatura.
 + Control y despliegue de periféricos por comando.
 + Recepción y transmisión de datos por RF.

Y la ERDYTC las siguientes:

 + Capacidad para mostrar datos recibidos y estados en LCD.
 + Ingreso de comandos por usuario y transmisión de los mismos.
 + Almacenamiento en memoria externa.
 + Recepción y transmisión de datos por RF.
* Estructura del código:

El sistema completo contará con dos codigos interdependientes, pero que se cargan a MCU distintos. Se identifican como SATDAC (cargado a BlackPill según /code//satdac//src//main.c/) y ERDYTC (cargado a NUCLEO según /code//erdytc//src//main.c/)). La edición de los archivos se realizó en Doom Emacs y se utilizó la herramienta de ST Atollic TRUEStudio para cargar los códigos a los MCU y para debuggear.

En ambos códigos, se describe paso a paso las líneas y decisiones tomadas. Se siguen los siguientes pasos en la estructura:

 + Se describen las librerías a utilizar en cada caso.
 + Se definen estructuras utilizadas en la configuración de componentes o pines del MCU.
 + Se definen constantes utilizadas en el código.
 + Se declaran las funciones locales utilizadas.
 + Se inicializan las determinadas componentes y pines dentro del */main/*.
 + Se desarrollan las interrupciones configuradas.
 + Se desarrollan las funciones locales declaradas al inicio.

Para la síntesis del código se utilizan las siguientes reglas:

 + Funciones creadas por el usuario se identifican en mayúsculas. Ej.: *MY_FUNCTION()*.
 + Variables globales o definiciones creadas por el usuario se identifican en minúsculas. Ej.: *myGlobalVar = x*.
 + Variables locales creadas por el usuario se identifican con la primer letra en mayúscula y el resto en minúsculas. Ej.: *MyLocalVar = x*.
 + Variables o definiciones que identifican pines de la placa se describen con un guión bajo al inicio. Ej.: *_led = GPIO_Pin_x*.
 + Variables o definiciones que identifican puertos de la placa se describen con un guión bajo al inicio y la primer letra en mayúsculas. Ej.: *_Led = GPIOx*.
 + Variables o definiciones que identifican pinSources se describen con dos guiones bajos al inicio. Ej.: *__led = GPIO_PinSourcex*.

* SATDAC:
:PROPERTIES:
:header-args: :tangle satdac/src/main.c
:END:

Aquí realizar una descripción más detallada del SATDAC, poner fotos de placas, prototipo físico terminado, etc.

** Librerias utilizadas:

Aquí se muestran las librerías utilizadas en el diseño del sistema.

 + Librería estándar, con las funciones y códigos básicos para microcontroladores STM32F4XX:

#+begin_src c
#include "stm32f4xx.h"
#include "stm32f4xx_gpio.h"
#include "stdio.h"
#include "misc.h"
#+end_src

 + Librería para el control del CLOCK del MCU:

#+begin_src c
#include "stm32f4xx_rcc.h"
#+end_src

 + Librería para el control de pines analógicos:

#+begin_src c
#include "stm32f4xx_adc.h"
#+end_src

 + Librería para el control de TIMERS:

#+begin_src c
#include "stm32f4xx_tim.h"
#+end_src

 + Libería para habilitar funciones matemáticas, como /pow()/:

#+begin_src c
#include "math.h"
#+end_src
** Estructuras:

En esta sección se declaran las diferentes estructuras utilizadas para la configuración de pines del MCU.

*** General:

La siguiente es la estructura para configuración de pines como salidas digitales:

#+begin_src c
GPIO_InitTypeDef    GPIO_InitStructure;
#+end_src

La siguiente es la estructura para la configuración y habilitación de interrupciones (por vencimiento de cuenta de TIMER, por DMA, etc.):

#+begin_src c
NVIC_InitTypeDef    NVIC_InitStructure;
#+end_src

La siguiente estructura se utiliza para configurar interrupciones externas; principalmente utilizada para interrupir según el estado de una entrada digital (pulsador, etc.):

#+begin_src c
EXTI_InitTypeDef   EXTI_InitStructure;
#+end_src

*** ADC:

Se definen las estructuras para inicializar pines como convertores analógico/digital:

#+begin_src c
ADC_InitTypeDef         ADC_InitStructure;
ADC_CommonInitTypeDef   ADC_CommonInitStructure;
#+end_src
*** TIMERS:

Las siguientes estructuras se utilizan en la configuración de TIMERS del MCU:

#+begin_src c
TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
TIM_OCInitTypeDef       TIM_OCInitStructure;
#+end_src

*** DMA:

La siguiente estructura se utiliza en la configuración y habilitación de la funcionalidad de DMA (/Acceso Directo a Memoria/):

#+begin_src c
DMA_InitTypeDef     DMA_InitStructure;
#+end_src

** Definición de constantes:
En esta sección se definen constantes a utilizar en el resto del código.

*** Hardware:

Aquí se definen como constantes los pines que se utilizarán en el hardware.

**** Servomotor:

#+begin_src c
#define _Servo      GPIOA
#define _servo      GPIO_Pin_3
#define __servo     GPIO_PinSource3
#+end_src

#+RESULTS:

*** Servomotor:

Frecuencia del PWM en Hz que controlorá el servomotor:

#+begin_src c
#define freqPWM 10e3
#+end_src

Ciclo de trabajo que definará la onda de salida PWM:

#+begin_src c
#define dutyCyclePWM 50
#+end_src

** Definición de funciones locales:

En esta sección se definen las distintas funciones a utilizar en el código local.

*** TIMERS:
**** TIM3:
Función para incializar el TIM3 del MCU con una determinada frecuencia.

 + *Returns*: void.
 + *Params* : freq - Frecuencia en /[Hz]/ a la que se inicializará el TIM3.

#+begin_src c
void INIT_TIM3(uint32_t freq);
#+end_src

**** TIM4:

Función para inicializar el TIM4 para el control de la salida PWM necesaria para el control del servomotor:

 + *Returns*: void.
 + *Params* : void.

#+begin_src c
void INIT_TIMPWM(void);
#+end_src

Función para inicializar las salidas PWM4:

 + *Returns*: void.
 + *Params* : void.

#+begin_src c
void INIT_PWM(void);
#+end_src

*** Servomotor:

Función para inicializar la salida del servomotor como PWM:

 + *Returns*: void.
 + *Params* : void.

#+begin_src c
void INIT_SERVO(void);
#+end_src

Función para iniciar el proceso de movimiento del servomotor.

 + *Returns*: void.
 + *Params* : void.

#+begin_src c
void MOVE_SERVO(void);
#+end_src

** Main:

En esta sección se encuentra la sección principal del código donde se inicializa y se llama a las funciones.

#+begin_src c
int main(void){
#+end_src

*** Inicialización:

En esta sección se inicializan las diferentes componentes del código. Este el procesamiento inicial que se realiza cuando se enciende el sistema.

Primeramente, se iniciliza el sistema según:

#+begin_src c
    SystemInit();
#+end_src

**** TIMERS:

Inicialización del TIM4 para el control del tiempo del PWM:

#+begin_src c
    INIT_TIMPWM();
#+end_src

Inicialización del PWM:

#+begin_src c
    INIT_PWM();
#+end_src
**** Servomotor:

Se inicializa el servomotor a la frecuencia /freqPWM/ establecida y con el /dutyCyclePWM/ seteado:

#+begin_src c
    INIT_SERVO();
#+end_src

*** Bucle pincipal:

Esta sección muestra el bucle principal infinito del código:

#+begin_src c
  while (1)
  {
  }
}
#+end_src
** Interrupciones:
** Funciones locales:
En esta sección se implementan las diferentes funciones del código.
*** TIMERS:
**** TIM4:
Este es el TIMER utilizado para el control de la salida PWM.
***** Inicialización del TIMER:
Aquí se inicializa el TIMER para setear la frecuencia inicial del PWM.

El primer paso se basa en la habilitación del clock para el TIM4; el cual está conectado al bus APB1.

Luego, como se quiere que la frecuencia del TIM sea la máxima, se seteará el prescaler en cero. Esto es debido a que la frecuencia de tick del TIM está definida como:

 + TIM_tickFreq = TIM_defaultFreq / (prescaller_set + 1)

De esta forma, se garantiza que TIM_tickFreq = TIM_defaultFreq.

Ahora, para setear el periodo del TIM cuando se resetea, primero se debe obtener el valor máximo para el timer. En este caso, como el TIM es de 16 bits, el valor máximo será 2^16 = 65535.

Para obtener la frecuencia del PWM, la ecuación es:

 + PWM_freq = TIM_tickFreq / (TIM_period + 1)
 + TIM_period = TIM_tickFreq / PWM_freq - 1

Finalmente, se terminan de inicializar los restantes parámetros y se carga la inicialización en la estructura del timer para dar comienzo al conteo.

#+begin_src c
void INIT_TIMPWM(void){
    /*Declaracion estructura particular:*/
    TIM_TimeBaseInitTypeDef TIM_BaseStruct;

    /*Activacion del clock:*/
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);

    /*Seteo del preescaler en 0 para obtener la maxima frecuencia:*/
    TIM_BaseStruct.TIM_Prescaler = 0;

    /*Seteo del conteo hacia arriba:*/
    TIM_BaseStruct.TIM_CounterMode = TIM_CounterMode_Up;

    /*Calculo periodo:*/
    TIM_BaseStruct.TIM_Period = SystemCoreClock / freqPWM - 1;

    /*Seteo de parametros restantes y carga a la estructura:*/
    TIM_BaseStruct.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_BaseStruct.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM4, &TIM_BaseStruct);

    /*Inicio del conteo:*/
    TIM_Cmd(TIM4, ENABLE);
}
#+end_src
***** Inicialización de las salidas PWM4:

Esta función setea los canales PWM a las salidas PWM del servo.

Primero, se setea el PWM en modo 2, lo que indica que la señal se generará comenzando en estado bajo. Luego, se habilitan las salidas PWM y se indica la polaridad.

Ahora, para calcular el duty cycle de la señal:

 + pulseLength = ((TIM_Period + 1)*dutyCyclePWM) / 100 - 1

donde dutyCycle está en porcentaje, entre 0% y 100%.

Por tanto, se crea una variable para calcular el periódo de trabajo del TIM4, llamada *Period*. Y entonces a partir de la misma se puede establecer el duty cycle del PWM.

Finalmente se carga la incialización a la estructura y se activa la salida.

#+begin_src c
void INIT_PWM(void){
    TIM_OCInitTypeDef TIM_OCStruct;

    TIM_OCStruct.TIM_OCMode = TIM_OCMode_PWM2;
    TIM_OCStruct.TIM_OutputState = TIM_OutputState_Enable;
    TIM_OCStruct.TIM_OCPolarity = TIM_OCPolarity_Low;

    uint32_t Period= SystemCoreClock / freqPWM - 1;

    TIM_OCStruct.TIM_Pulse = ((Period + 1) * dutyCyclePWM) / 100 - 1;

    TIM_OC1Init(TIM4, &TIM_OCStruct);
    TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Enable);
}
#+end_src
*** Servomotor:

Aquí se describen las funciones relacionadas con el funcionamiento del servomotor.

**** Inicialización:

Esta función inicializa la salida correspondiente al servo con soporte para PWM disparado según el TIM4.

Se comienza habilitando el clock para el puerto donde estará la salida PWM (GPIOA - Pin 3). Configuración de la función alternante PWM disparada por el TIM4 para el pin correspondiente al servo.

Se setea el pin finalmente y se carga en la estructura.

#+begin_src c
void INIT_SERVO(void){
    GPIO_InitTypeDef GPIO_InitStruct;

    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);

    GPIO_PinAFConfig(_Servo, __servo, GPIO_AF_TIM4);

    GPIO_InitStruct.GPIO_Pin = _servo;
    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_100MHz;
    GPIO_Init(GPIOD, &GPIO_InitStruct);
}
#+end_src
* ERDYTC:
:PROPERTIES:
:header-args: :tangle erdytc/src/main.c
:END:

Aquí realizar una descripción más detallada del sistema, poner fotos de placas, prototipo físico terminado, etc.

** Librerías utilizadas:

Aquí se muestran las librerías utilizadas en el diseño del sistema.

 + Librería estándar, con las funciones y códigos básicos para microcontroladores STM32F4XX:

#+begin_src c
#include "stm32f4xx.h"
#include "stm32f4xx_gpio.h"
#include "stdio.h"
#include "misc.h"
#+end_src

 + Librería para el control del CLOCK del MCU:

#+begin_src c
#include "stm32f4xx_rcc.h"
#+end_src

 + Librería para el control de TIMERS:

#+begin_src c
#include "stm32f4xx_tim.h"
#+end_src

 + Libería para habilitar funciones matemáticas, como /pow()/:

#+begin_src c
#include "math.h"
#+end_src

** Estructuras:

En esta sección se declaran las diferentes estructuras utilizadas para la configuración de pines del MCU.

*** General:

La siguiente es la estructura para configuración de pines como salidas digitales:

#+begin_src c
GPIO_InitTypeDef    GPIO_InitStructure;
#+end_src

La siguiente es la estructura para la configuración y habilitación de interrupciones (por vencimiento de cuenta de TIMER, por DMA, etc.):

#+begin_src c
NVIC_InitTypeDef    NVIC_InitStructure;
#+end_src

La siguiente estructura se utiliza para configurar interrupciones externas; principalmente utilizada para interrupir según el estado de una entrada digital (pulsador, etc.):

#+begin_src c
EXTI_InitTypeDef   EXTI_InitStructure;
#+end_src

*** TIMERS:

Las siguientes estructuras se utilizan en la configuración de TIMERS del MCU:

#+begin_src c
TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
TIM_OCInitTypeDef       TIM_OCInitStructure;
#+end_src

*** DMA:

La siguiente estructura se utiliza en la configuración y habilitación de la funcionalidad de DMA (/Acceso Directo a Memoria/):

#+begin_src c
DMA_InitTypeDef     DMA_InitStructure;
#+end_src

** Definición de constantes:
En esta sección se definen constantes a utilizar en el resto del código.

*** Hardware:

Aquí se definen como constantes los pines que se utilizarán en el hardware.

*** LCD:

Aquí se definen distintas constantes que se utilizan en las funciones de control del LCD:

#+begin_src c
#define  TLCD_INIT_PAUSE        100000
#define  TLCD_PAUSE             50000
#define  TLCD_CLK_PAUSE         1000
#define  TLCD_MAXX              16
#define  TLCD_MAXY              2
#define  MaxDigCount            4095
#define  MaxMiliVoltRef         3320
#define  Res32Bit               32
#define  DAC_DHR12R2_ADDRESS    0x40007414
#define  TLCD_CMD_INIT_DISPLAY  0x28
#define  TLCD_CMD_ENTRY_MODE    0x06
#define  TLCD_CMD_DISP_M0       0x08
#define  TLCD_CMD_DISP_M1       0x0C
#define  TLCD_CMD_DISP_M2       0x0E
#define  TLCD_CMD_DISP_M3       0x0F
#define  TLCD_CMD_CLEAR         0x01
#+end_src

La estructura para identificar los pines del LCD:

#+begin_src c
typedef enum
{
  TLCD_RS = 0,  // RS-Pin
  TLCD_E  = 1,  // E-Pin
  TLCD_D4 = 2,  // DB4-Pin
  TLCD_D5 = 3,  // DB5-Pin
  TLCD_D6 = 4,  // DB6-Pin
  TLCD_D7 = 5   // DB7-Pin
}TLCD_NAME_t;
#+end_src

Se define el nombre del LCD como una constante:

#+begin_src c
#define  TLCD_ANZ   6
#+end_src

Y se crea una estructura con los estados del mismo:

#+begin_src c
typedef enum {
  TLCD_OFF = 0,
  TLCD_ON,
  TLCD_CURSOR,
  TLCD_BLINK
}TLCD_MODE_t;
#+end_src

Finalmente la estructura para crear el objeto LCD (de 2x16 que se utilizará en este caso):

#+begin_src c
typedef struct {
  TLCD_NAME_t TLCD_NAME;
  GPIO_TypeDef* TLCD_PORT;
  const uint16_t TLCD_PIN;
  const uint32_t TLCD_CLK;
  BitAction TLCD_INIT;
}LCD_2X16_t;
#+end_src

** Definición de funciones locales:

En esta sección se definen las distintas funciones a utilizar en el código local.

*** General:

Aquí se definen funciones locales que son utilizadas por varias componentes del código.

Función para determinar el nombre formal del clock para un determinado puerto:

 + *Returns*: /uint32_t/ con el dato del CLOCK.
 + *Params.*: Nombre del puerto a determinar.

#+begin_src c
uint32_t FIND_CLOCK(GPIO_TypeDef* Port);
#+end_src
*** LCD:

Las siguientes funciones se definen para determinar varios parámetros y cualidades del display LCD:

#+begin_src c
void P_LCD_2x16_InitIO(LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_PinLo(TLCD_NAME_t lcd_pin, LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_PinHi(TLCD_NAME_t lcd_pin, LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_Delay(volatile uint32_t nCount);
void P_LCD_2x16_InitSequenz(LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_Clk(LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_Cmd(uint8_t wert, LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_Cursor(LCD_2X16_t* LCD_2X16, uint8_t x, uint8_t y);
void P_LCD_2x16_Data(uint8_t wert, LCD_2X16_t* LCD_2X16);
#+end_src

Función para inicializar los pines del LCD:

 + *Returns*: void.
 + *Params.*: Matriz tipo LCD_2X16_t con los pines detallados del LCD.

#+begin_src c
void INIT_LCD_2x16(LCD_2X16_t* LCD_2X16);
#+end_src

Función para refrescar la pantalla del LCD:

 + *Returns*: void.
 + *Params.*: Matriz tipo LCD_2X16_t con los pines detallados del LCD.

#+begin_src c
void CLEAR_LCD_2x16(LCD_2X16_t* LCD_2X16);
#+end_src

Función para para imprimir una string dictada por el usuario en la pantalla del LCD:

 + *Returns*: void.
 + *Params.*:
   + Matriz tipo LCD_2X16_t con los pines detallados del LCD.
   + Un indicador /x/ para indentificar la columna del LCD donde se iniciará la string.
   + Un indicardor /y/ para identificar la fila del LCD donde se iniciará la string.
   + Una string o puntero a la misma.

#+begin_src c
void PRINT_LCD_2x16(LCD_2X16_t* LCD_2X16, uint8_t x, uint8_t y, char *ptr);
#+end_src

*** TIMERS:
**** TIM3:
Función para incializar el TIM3 del MCU con una determinada frecuencia.

 + *Returns*: void.
 + *Params* : freq - Frecuencia en /[Hz]/ a la que se inicializará el TIM3.

#+begin_src c
void INIT_TIM3(uint32_t freq);
#+end_src

** Main:

En esta sección se encuentra la sección principal del código donde se inicializa y se llama a las funciones.

#+begin_src c
int main(void){
#+end_src

*** Inicialización:

En esta sección se inicializan las diferentes componentes del código. Este el procesamiento inicial que se realiza cuando se enciende el sistema.

Primeramente, se iniciliza el sistema según:

#+begin_src c
    SystemInit();
#+end_src

*** Bucle pincipal:

Esta sección muestra el bucle principal infinito del código:

#+begin_src c
  while (1)
  {
  }
}
#+end_src
** Interrupciones:
** Funciones locales:

En esta sección se implementan las diferentes funciones del código.

*** LCD:

**** Internas:

Inicialización de los pines del display:

#+begin_src c
void P_LCD_2x16_InitIO(LCD_2X16_t* LCD_2X16)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    TLCD_NAME_t lcd_pin;

    for (lcd_pin = 0; lcd_pin < TLCD_ANZ; lcd_pin++)
    {
        //Habilitacion del Clock para cada PIN:
        RCC_AHB1PeriphClockCmd(LCD_2X16[lcd_pin].TLCD_CLK, ENABLE);

        //Configuracion como salidas digitales:
        GPIO_InitStructure.GPIO_Pin = LCD_2X16[lcd_pin].TLCD_PIN;
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
        GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
        GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
        GPIO_Init(LCD_2X16[lcd_pin].TLCD_PORT, &GPIO_InitStructure);

        //Default Wert einstellen
        if(LCD_2X16[lcd_pin].TLCD_INIT == Bit_RESET)
            P_LCD_2x16_PinLo(lcd_pin, LCD_2X16);
        else
            P_LCD_2x16_PinHi(lcd_pin, LCD_2X16);
    }
}
#+end_src

Cambiar el estado de un pin a alto o bajo:

#+begin_src c
void P_LCD_2x16_PinLo(TLCD_NAME_t lcd_pin, LCD_2X16_t* LCD_2X16)
{
  LCD_2X16[lcd_pin].TLCD_PORT->BSRRH = LCD_2X16[lcd_pin].TLCD_PIN;
}

void P_LCD_2x16_PinHi(TLCD_NAME_t lcd_pin, LCD_2X16_t* LCD_2X16)
{
  LCD_2X16[lcd_pin].TLCD_PORT->BSRRL = LCD_2X16[lcd_pin].TLCD_PIN;
}
#+end_src

Retardo utilizado en las funciones del LCD:

#+begin_src c
void P_LCD_2x16_Delay(volatile uint32_t nCount)
{
  while(nCount--)
  {
  }
}
#+end_src

Inicialización de secuencia del LCD:

#+begin_src c
void P_LCD_2x16_InitSequenz(LCD_2X16_t* LCD_2X16)
{
  //Inicializacion de la secuencia:
  P_LCD_2x16_PinHi(TLCD_D4, LCD_2X16);
  P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16);
  P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  // Erster Init Impuls
  P_LCD_2x16_Clk(LCD_2X16);
  P_LCD_2x16_Delay(TLCD_PAUSE);
  // Zweiter Init Impuls
  P_LCD_2x16_Clk(LCD_2X16);
  P_LCD_2x16_Delay(TLCD_PAUSE);
  // Dritter Init Impuls
  P_LCD_2x16_Clk(LCD_2X16);
  P_LCD_2x16_Delay(TLCD_PAUSE);
  // LCD-Modus einstellen (4Bit-Mode)
  P_LCD_2x16_PinLo(TLCD_D4, LCD_2X16);
  P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16);
  P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  P_LCD_2x16_Clk(LCD_2X16);
  P_LCD_2x16_Delay(TLCD_PAUSE);
}
#+end_src

Configuración del clock del LCD:

#+begin_src c
void P_LCD_2x16_Clk(LCD_2X16_t* LCD_2X16)
{
  // Pin-E auf Hi
  P_LCD_2x16_PinHi(TLCD_E, LCD_2X16);
  // kleine Pause
  P_LCD_2x16_Delay(TLCD_CLK_PAUSE);
  // Pin-E auf Lo
  P_LCD_2x16_PinLo(TLCD_E, LCD_2X16);
  // kleine Pause
  P_LCD_2x16_Delay(TLCD_CLK_PAUSE);
}
#+end_src

Comandos utilizados en las funciones del LCD:

#+begin_src c
void P_LCD_2x16_Cmd(uint8_t wert, LCD_2X16_t* LCD_2X16)
{
  // RS=Lo (Command)
  P_LCD_2x16_PinLo(TLCD_RS, LCD_2X16);
  // Hi-Nibble ausgeben
  if((wert&0x80)!=0) P_LCD_2x16_PinHi(TLCD_D7, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  if((wert&0x40)!=0) P_LCD_2x16_PinHi(TLCD_D6, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  if((wert&0x20)!=0) P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D5, LCD_2X16);
  if((wert&0x10)!=0) P_LCD_2x16_PinHi(TLCD_D4, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D4, LCD_2X16);
  P_LCD_2x16_Clk(LCD_2X16);
  // Lo-Nibble ausgeben
  if((wert&0x08)!=0) P_LCD_2x16_PinHi(TLCD_D7, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  if((wert&0x04)!=0) P_LCD_2x16_PinHi(TLCD_D6, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  if((wert&0x02)!=0) P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D5, LCD_2X16);
  if((wert&0x01)!=0) P_LCD_2x16_PinHi(TLCD_D4, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D4, LCD_2X16);
  P_LCD_2x16_Clk(LCD_2X16);
}

void P_LCD_2x16_Cursor(LCD_2X16_t* LCD_2X16, uint8_t x, uint8_t y)
{
  uint8_t wert;

  if(x>=TLCD_MAXX) x=0;
  if(y>=TLCD_MAXY) y=0;

  wert=(y<<6);
  wert|=x;
  wert|=0x80;
  P_LCD_2x16_Cmd(wert,LCD_2X16);
}
#+end_src

Análisis de datos del LCD:

#+begin_src c
void P_LCD_2x16_Data(uint8_t wert, LCD_2X16_t* LCD_2X16)
{
  // RS=Hi (Data)
  P_LCD_2x16_PinHi(TLCD_RS, LCD_2X16);
  // Hi-Nibble ausgeben
  if((wert&0x80)!=0) P_LCD_2x16_PinHi(TLCD_D7, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  if((wert&0x40)!=0) P_LCD_2x16_PinHi(TLCD_D6, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  if((wert&0x20)!=0) P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D5, LCD_2X16);
  if((wert&0x10)!=0) P_LCD_2x16_PinHi(TLCD_D4, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D4, LCD_2X16);
  P_LCD_2x16_Clk(LCD_2X16);
  // Lo-Nibble ausgeben
  if((wert&0x08)!=0) P_LCD_2x16_PinHi(TLCD_D7, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  if((wert&0x04)!=0) P_LCD_2x16_PinHi(TLCD_D6, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  if((wert&0x02)!=0) P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D5, LCD_2X16);
  if((wert&0x01)!=0) P_LCD_2x16_PinHi(TLCD_D4, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D4, LCD_2X16);
  P_LCD_2x16_Clk(LCD_2X16);
}
#+end_src
**** Funcionalidad:

***** Inicialización de los pines del LCD:

#+begin_src c
void INIT_LCD_2x16(LCD_2X16_t* LCD_2X16)
{
    //Inicialización de los pines del LCD:
    P_LCD_2x16_InitIO(LCD_2X16);
    // kleine Pause
    P_LCD_2x16_Delay(TLCD_INIT_PAUSE);
    // Init Sequenz starten
    P_LCD_2x16_InitSequenz(LCD_2X16);
    // LCD-Settings einstellen
    P_LCD_2x16_Cmd(TLCD_CMD_INIT_DISPLAY, LCD_2X16);
    P_LCD_2x16_Cmd(TLCD_CMD_ENTRY_MODE, LCD_2X16);
    // Display einschalten
    P_LCD_2x16_Cmd(TLCD_CMD_DISP_M1, LCD_2X16);
    // Display l�schen
    P_LCD_2x16_Cmd(TLCD_CMD_CLEAR, LCD_2X16);
    // kleine Pause
    P_LCD_2x16_Delay(TLCD_PAUSE);
}
#+end_src
***** Refresco de pantalla:

#+begin_src c
void CLEAR_LCD_2x16(LCD_2X16_t* LCD_2X16)
{
  // Display l�schen
  P_LCD_2x16_Cmd(TLCD_CMD_CLEAR, LCD_2X16);
  // kleine Pause
  P_LCD_2x16_Delay(TLCD_PAUSE);
}
#+end_src
***** Imprimir en pantalla:

#+begin_src c
void PRINT_LCD_2x16(LCD_2X16_t* LCD_2X16, uint8_t x, uint8_t y, char *ptr)
{
  // Cursor setzen
  P_LCD_2x16_Cursor(LCD_2X16,x,y);
  // kompletten String ausgeben
  while (*ptr != 0) {
    P_LCD_2x16_Data(*ptr, LCD_2X16);
    ptr++;
  }
}
#+end_src
