#+TITLE: Sistema de adquisición de datos y lógica digital base para implementación en CubeSats
#+AUTHOR: A. Riedinger & G. Garcia

* ÍNDICE :toc:
- [[#sobre-el-proyecto][SOBRE EL PROYECTO]]
- [[#estructura-y-reglas][ESTRUCTURA Y REGLAS]]
- [[#satdac][SATDAC]]
  - [[#librerias][LIBRERIAS]]
  - [[#header][HEADER]]
  - [[#main][MAIN]]
  - [[#interrupciones][INTERRUPCIONES]]
  - [[#funciones-locales][FUNCIONES LOCALES]]
- [[#erdytc][ERDYTC]]
  - [[#librerias-1][LIBRERIAS]]
  - [[#header-1][HEADER]]
  - [[#main-1][MAIN]]
  - [[#interrupciones-1][INTERRUPCIONES]]
  - [[#funciones-locales-1][FUNCIONES LOCALES]]

* SOBRE EL PROYECTO

El objetivo del proyecto es construir la base lógica digital inicial, como *prueba de concepto*, para aplicación en un CubeSat.

CubeSat es un estándar de diseño de nanosatélites, cuya estructura es escalable en cubos de 10 cm de arista y masa inferior a 1,33 kg. La premisa de este trabajo se basa en el diseño de un sistema de adquisición y transmisión de datos según el MCU STM32F4-BlackPill y en una estación de recepción de datos y transmisión de comandos según el MCU STM32F429ZI.

Esto es, el proyecto se divide en dos sistemas que trabajan de forma codependiente pero que son controlados por microcontroladores distintos:

 + Uno es el SATDAC (Sistema de Adquisicón y Transmisión de Datos Autosuficiente y Controlable), que estaría ubicado dentro del hipotético CubeSat.
 + Otro es el ERDYTC (Estación de Recepción de Datos Y Transmisión de Comandos), que se encontraría fuera del CubeSat.

El SATDAC posee las siguientes capacidades:

 + Sensado de temperatura.
 + Control y despliegue de periféricos por comando.
 + Recepción y transmisión de datos por RF.

Y la ERDYTC las siguientes:

 + Capacidad para mostrar datos recibidos y estados en LCD.
 + Ingreso de comandos por usuario y transmisión de los mismos.
 + Almacenamiento en memoria externa.
 + Recepción y transmisión de datos por RF.
* ESTRUCTURA Y REGLAS

El sistema completo contará con dos codigos interdependientes, pero que se cargan a MCU distintos. Se identifican como SATDAC (cargado a BlackPill según /code//satdac//src//main.c/) y ERDYTC (cargado a NUCLEO según /code//erdytc//src//main.c/)). La edición de los archivos se realizó en Doom Emacs y se utilizó la herramienta de ST Atollic TRUEStudio para cargar los códigos a los MCU y para debuggear.

En ambos códigos, se describe paso a paso las líneas y decisiones tomadas. Se siguen los siguientes pasos en la estructura:

 + Se describen las librerías a utilizar en cada caso.
 + Se definen estructuras utilizadas en la configuración de componentes o pines del MCU.
 + Se definen constantes utilizadas en el código.
 + Se declaran las funciones locales utilizadas.
 + Se inicializan las determinadas componentes y pines dentro del */main/*.
 + Se desarrollan las interrupciones configuradas.
 + Se desarrollan las funciones locales declaradas al inicio.

Para la síntesis del código se utilizan las siguientes reglas:

 + Funciones creadas por el usuario se identifican en mayúsculas. Ej.: *MY_FUNCTION()*.
 + Variables globales o definiciones creadas por el usuario se identifican en minúsculas. Ej.: *myGlobalVar = x*.
 + Variables locales creadas por el usuario se identifican con la primer letra en mayúscula y el resto en minúsculas. Ej.: *MyLocalVar = x*.
 + Variables o definiciones que identifican pines de la placa se describen con un guión bajo al inicio. Ej.: *_led = GPIO_Pin_x*.
 + Variables o definiciones que identifican puertos de la placa se describen con un guión bajo al inicio y la primer letra en mayúsculas. Ej.: *_Led = GPIOx*.
 + Variables o definiciones que identifican pinSources se describen con dos guiones bajos al inicio. Ej.: *__led = GPIO_PinSourcex*.

* SATDAC
:PROPERTIES:
:header-args: :tangle satdac/src/main.c
:END:

Aquí realizar una descripción más detallada del SATDAC, poner fotos de placas, prototipo físico terminado, etc.

** LIBRERIAS

En el proyecto se utilizan las siguientes librerías:

 + *Librerías estándar:* contienen las funciones y códigos básicos para microcontroladores STM32F4XX. Esto incluye todas las funciones para cambiar estados de puertos (/GPIO_Set_Bit()/, etc.) y las específicas como de definición de estructuras.
 + *Control del clock:* contiene las funciones relacionadas al control del clock del MCU, como por ejemplo /RCC_AHB1PeriphClockCmd()/ y demás.
 + *Control de pines analógicos:* contiene las funciones necesarias para configurar determinados como analógicos.
   + *RECORDAR*: los pines configurados como analógicos *NO PUEDEN RECIBIR UN VOLTAJE MAYOR A 3 V*.
 + *Control de timers:* incluye las funciones /TIM_*()/ necesarias para la configuración de timers del MCU.
 + *Matemáticas:* incluye funciones para realizar operaciones matemáticas básicas en /C/, como sea /pow()/ y demás.

#+begin_src c
/*----------------------------------------------------------------*/
/*LIBRERIAS:                                                      */
/*----------------------------------------------------------------*/
/*Librerias estandar:*/
#include "stm32f4xx.h"
#include "stm32f4xx_gpio.h"
#include "stdio.h"
#include "misc.h"

/*Control del clock:*/
#include "stm32f4xx_rcc.h"

/*Control de pines analogicos*/
#include "stm32f4xx_adc.h"

/*Control de timers:*/
#include "stm32f4xx_tim.h"

/*Matematicas:*/
#include "math.h"
#+end_src

** HEADER

En esta sección se declaran diferentes parámetros con valores fijos que se utilizarán luego a lo largo del código. El propósito de esto yace en independizar los valores abstractos y en su lugar utilizar nombres que ayuden a la interpretación del código.

#+begin_src c
/*----------------------------------------------------------------*/
/*DEFINICIONES:                                                   */
/*----------------------------------------------------------------*/
#+end_src

*** ESTRUCTURAS

En esta sección se declaran las diferentes estructuras utilizadas para la configuración de pines del MCU:

 + *General:* son estructuras genéricas que se utilzan para la configuración de aplicaciones básicas del MCU. Estas son:
   + Configuración de pines como salidas digitales.
   + Habilitacion de interrupciones.
   + Configuración de interrupciones externas.
 + *ADC:* utilizadas para la inicialización de pines como convertores analógico/digital.
 + *TIMERS:* utilizadas en la configuración de timers del MCU.
 + *DMA:* utilizadas para la habilitación del /Acceso Directo a Memoria/.

#+begin_src c
/* * * * * * * * * * * * * ESTRUCTURAS * * * * * * * * * * * * */
/*General:*/
GPIO_InitTypeDef        GPIO_InitStructure;
NVIC_InitTypeDef        NVIC_InitStructure;
EXTI_InitTypeDef        EXTI_InitStructure;

/*ADC:*/
ADC_InitTypeDef         ADC_InitStructure;
ADC_CommonInitTypeDef   ADC_CommonInitStructure;

/*TIMERS*/
TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
TIM_OCInitTypeDef       TIM_OCInitStructure;

/*DMA*/
DMA_InitTypeDef         DMA_InitStructure;
#+end_src

*** CONSTANTES

Aquí se declaran diferentes parámetros, que pueden tanto ser los puertos y pines que se utilizan en el hardware, como variables que poseen un valor fijo:

 + *Hardware:* se definen los pines en los que se conectan los elementos de hardware del sistema. Estos son:
   + *Servomotor:* conectado en el pin PA3.
 + *Parámetros:* se definen variables de valor fijo que se utilizarán adelante en el código. Estas son:
   + *Frecuencia PWM:* utilizada para el control del servomotor; su valor DEBE ser dado en Herzios (/Hz/).
   + *Ciclo de trabajo PWM:* define el duty cycle de la onda de salida PWM para controlar el servomotor.

#+begin_src c
/* * * * * * * * * * * * * CONSTANTES * * * * * * * * * * * * */
/* - - - - HARDWARE - - - -*/
/*Servomotor:*/
#define _Servo      GPIOA
#define _servo      GPIO_Pin_3
#define __servo     GPIO_PinSource3

/* - - - - PARAMS. - - - -*/
/*Frecuencia PWM:*/
#define freqPWM 10e3

/*Ciclo de trabajo PWM:*/
#define dutyCyclePWM 50
#+end_src
*** VARIABLES GLOBALES
a
*** FUNCIONES LOCALES

En esta sección se definen los encabezados de las distintas funciones a utilizar en el código local:

 + *Inicialización TIM3:* función para incializar el TIM3 del MCU con una determinada frecuencia.
   + *Returns*: void.
   + *Params* : freq - Frecuencia en /[Hz]/ a la que se inicializará el TIM3.
 + *Inicialización TIM4:* función para inicializar el TIM4 para el control de la salida PWM necesaria para el control del servomotor.
   + *Returns*: void.
   + *Params* : void.
 + *Inicialización PWM:* función para inicializar las salidas PWM4.
   + *Returns*: void.
   + *Params* : void.
 + *Inicialización servo:* Función para inicializar la salida del servomotor como PWM:
   + *Returns*: void.
   + *Params* : void.
 + *Mover servo:* Función para iniciar el proceso de movimiento del servomotor.
   + *Returns*: void.
   + *Params* : void.

#+begin_src c
/* * * * * * * * * * * * * FUNCIONES * * * * * * * * * * * * */
/*Inicializacion TIM3:*/
void INIT_TIM3(uint32_t freq);

/*Inicializacion TIM4:*/
void INIT_TIMPWM(void);

/*Inicializacion PWM:*/
void INIT_PWM(void);

/*Inicializacion servo:*/
void INIT_SERVO(void);

/*Mover servo:*/
void MOVE_SERVO(void);

void TEMP(void);
#+end_src

** MAIN

En esta parte se encuentra la sección principal del código donde se inicializa y se llama a las funciones. Además, se realizan diferentes procesamientos en el bucle principal.

#+begin_src c
/*----------------------------------------------------------------*/
/*MAIN:                                                           */
/*----------------------------------------------------------------*/
int main(void){
#+end_src

*** INICIALIZACION

En esta sección se inicializan las diferentes componentes del código. Este el procesamiento inicial que se realiza cuando se enciende el sistema.

Las funciones llamadas para inicializar son las siguientes:
 + *Inicio del sistema:* función general de las librerías estándar para inicializar las funciones del MCU.
 + *Inicialización de timers:* se llama a las funciones de inicialización de timers descritas en la sección de definciones. Estas son:
   + Inicialización del TIM3.
   + Inicialización del TIM4.
   + Inicialización del PWM.
 + *Servomotor:* se inicializan las funciones relacionadas al manejo del servomotor. Estas son:
   + Inicialización de la salida del servo.

#+begin_src c
/* * * * * * * * * * * * * INICIALIZ. * * * * * * * * * * * * */
    /*Inicio del sistema:*/
    SystemInit();

    /*Inicializacion de timers:*/
    INIT_TIMPWM();
    INIT_PWM();

    /*Servomotor:*/
    INIT_SERVO();
#+end_src

*** BUCLE PPAL.:

Esta sección muestra el bucle principal infinito del código:

#+begin_src c
/* * * * * * * * * * * * * BUCLE PPAL. * * * * * * * * * * * * */
  while (1)
  {
  }
}
#+end_src
** INTERRUPCIONES
** FUNCIONES LOCALES

En esta sección se implementan las diferentes funciones del código.

#+begin_src c
/*----------------------------------------------------------------*/
/*FUNCIONES LOCALES:                                              */
/*----------------------------------------------------------------*/
#+end_src

*** TIMERS:
**** TIM4:
Este es el TIMER utilizado para el control de la salida PWM.
***** Inicialización del TIMER:
Aquí se inicializa el TIMER para setear la frecuencia inicial del PWM.

El primer paso se basa en la habilitación del clock para el TIM4; el cual está conectado al bus APB1.

Luego, como se quiere que la frecuencia del TIM sea la máxima, se seteará el prescaler en cero. Esto es debido a que la frecuencia de tick del TIM está definida como:

 + TIM_tickFreq = TIM_defaultFreq / (prescaller_set + 1)

De esta forma, se garantiza que TIM_tickFreq = TIM_defaultFreq.

Ahora, para setear el periodo del TIM cuando se resetea, primero se debe obtener el valor máximo para el timer. En este caso, como el TIM es de 16 bits, el valor máximo será 2^16 = 65535.

Para obtener la frecuencia del PWM, la ecuación es:

 + PWM_freq = TIM_tickFreq / (TIM_period + 1)
 + TIM_period = TIM_tickFreq / PWM_freq - 1

Finalmente, se terminan de inicializar los restantes parámetros y se carga la inicialización en la estructura del timer para dar comienzo al conteo.

#+begin_src c
void INIT_TIMPWM(void){
    /*Declaracion estructura particular:*/
    TIM_TimeBaseInitTypeDef TIM_BaseStruct;

    /*Activacion del clock:*/
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);

    /*Seteo del preescaler en 0 para obtener la maxima frecuencia:*/
    TIM_BaseStruct.TIM_Prescaler = 0;

    /*Seteo del conteo hacia arriba:*/
    TIM_BaseStruct.TIM_CounterMode = TIM_CounterMode_Up;

    /*Calculo periodo:*/
    TIM_BaseStruct.TIM_Period = SystemCoreClock / freqPWM - 1;

    /*Seteo de parametros restantes y carga a la estructura:*/
    TIM_BaseStruct.TIM_ClockDivision = TIM_CKD_DIV1;
    TIM_BaseStruct.TIM_RepetitionCounter = 0;
    TIM_TimeBaseInit(TIM4, &TIM_BaseStruct);

    /*Inicio del conteo:*/
    TIM_Cmd(TIM4, ENABLE);
}
#+end_src
***** Inicialización de las salidas PWM4:

Esta función setea los canales PWM a las salidas PWM del servo.

Primero, se setea el PWM en modo 2, lo que indica que la señal se generará comenzando en estado bajo. Luego, se habilitan las salidas PWM y se indica la polaridad.

Ahora, para calcular el duty cycle de la señal:

 + pulseLength = ((TIM_Period + 1)*dutyCyclePWM) / 100 - 1

donde dutyCycle está en porcentaje, entre 0% y 100%.

Por tanto, se crea una variable para calcular el periódo de trabajo del TIM4, llamada *Period*. Y entonces a partir de la misma se puede establecer el duty cycle del PWM.

Finalmente se carga la incialización a la estructura y se activa la salida.

#+begin_src c
void INIT_PWM(void){
    TIM_OCInitTypeDef TIM_OCStruct;

    TIM_OCStruct.TIM_OCMode = TIM_OCMode_PWM2;
    TIM_OCStruct.TIM_OutputState = TIM_OutputState_Enable;
    TIM_OCStruct.TIM_OCPolarity = TIM_OCPolarity_Low;

    uint32_t Period= SystemCoreClock / freqPWM - 1;

    TIM_OCStruct.TIM_Pulse = ((Period + 1) * dutyCyclePWM) / 100 - 1;

    TIM_OC1Init(TIM4, &TIM_OCStruct);
    TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Enable);
}
#+end_src
*** Servomotor:

Aquí se describen las funciones relacionadas con el funcionamiento del servomotor.

**** Inicialización:

Esta función inicializa la salida correspondiente al servo con soporte para PWM disparado según el TIM4.

Se comienza habilitando el clock para el puerto donde estará la salida PWM (GPIOA - Pin 3). Configuración de la función alternante PWM disparada por el TIM4 para el pin correspondiente al servo.

Se setea el pin finalmente y se carga en la estructura.

#+begin_src c
void INIT_SERVO(void){
    GPIO_InitTypeDef GPIO_InitStruct;

    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);

    GPIO_PinAFConfig(_Servo, __servo, GPIO_AF_TIM4);

    GPIO_InitStruct.GPIO_Pin = _servo;
    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_100MHz;
    GPIO_Init(GPIOD, &GPIO_InitStruct);
}
#+end_src
* ERDYTC
:PROPERTIES:
:header-args: :tangle erdytc/src/main.c
:END:

Aquí realizar una descripción más detallada del sistema, poner fotos de placas, prototipo físico terminado, etc.

** LIBRERIAS

En el proyecto se utilizan las siguientes librerías:

 + *Librerías estándar:* contienen las funciones y códigos básicos para microcontroladores STM32F4XX. Esto incluye todas las funciones para cambiar estados de puertos (/GPIO_Set_Bit()/, etc.) y las específicas como de definición de estructuras.
 + *Control del clock:* contiene las funciones relacionadas al control del clock del MCU, como por ejemplo /RCC_AHB1PeriphClockCmd()/ y demás.
 + *Control de timers:* incluye las funciones /TIM_*()/ necesarias para la configuración de timers del MCU.
 + *Control de interrupción por pulso externo:* incluye las funciones para la configuración de entradas como EXTI, habilitando la interrupción a un pulso externo.
 + *Control del protocolo USART:* habilita las funciones necesarias para utilizar el protocolo USART.
 + *Matemáticas:* incluye funciones para realizar operaciones matemáticas básicas en /C/, como sea /pow()/ y demás.

#+begin_src c
/*----------------------------------------------------------------*/
/*LIBRERIAS:                                                      */
/*----------------------------------------------------------------*/
/*Librerias estandar:*/
#include "stm32f4xx.h"
#include "stm32f4xx_gpio.h"
#include "stdio.h"
#include "misc.h"

/*Control del clock:*/
#include "stm32f4xx_rcc.h"

/*Control de timers:*/
#include "stm32f4xx_tim.h"

/*Control de interrupcion por pulso externo:*/
#include "stm32f4xx_exti.h"

/*Control del protocolo USART:*/
#include "stm32f4xx_usart.h"
#include "string.h"

/*Matematicas:*/
#include "math.h"
#+end_src

** HEADER

En esta sección se declaran diferentes parámetros con valores fijos que se utilizarán luego a lo largo del código. El propósito de esto yace en independizar los valores abstractos y en su lugar utilizar nombres que ayuden a la interpretación del código.

#+begin_src c
/*----------------------------------------------------------------*/
/*HEADER:                                                         */
/*----------------------------------------------------------------*/
#+end_src

*** ESTRUCTURAS

En esta sección se declaran las diferentes estructuras utilizadas para la configuración de pines del MCU:

 + *General:* son estructuras genéricas que se utilzan para la configuración de aplicaciones básicas del MCU. Estas son:
   + Configuración de pines como salidas digitales.
   + Habilitacion de interrupciones.
   + Configuración de interrupciones externas.
 + *TIMERS:* utilizadas en la configuración de timers del MCU.
 + *DMA:* utilizadas para la habilitación del /Acceso Directo a Memoria/.

#+begin_src c
/* * * * * * * * * * * * * ESTRUCTURAS * * * * * * * * * * * * */
/*General:*/
GPIO_InitTypeDef        GPIO_InitStructure;
NVIC_InitTypeDef        NVIC_InitStructure;
EXTI_InitTypeDef        EXTI_InitStructure;

/*TIMERS*/
TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
TIM_OCInitTypeDef       TIM_OCInitStructure;

/*DMA*/
DMA_InitTypeDef         DMA_InitStructure;
#+end_src

*** CONSTANTES

Aquí se declaran diferentes parámetros, que pueden tanto ser los puertos y pines que se utilizan en el hardware, como variables que poseen un valor fijo:

 + *LCD:* se definen variables de valor fijo, constantes y estructuras que se utilizan en las funciones de manejo del LCD. Estas son:
   + *Constantes varias:* utilizadas para reemplazar determinados valores en las funciones del LCD.
   + *Identificación pines:* estructura que se utiliza para nombrar a los pines del LCD en la definición del mismo.
   + *Nombre LCD:* se define el nombre del LCD como una constante.
   + *Estados LCD:* estructura utilizada para distinguir los distinto estados del LCD.
   + *Crear LCD:* estructura utilizada para crear el objeto LCD sobre el cuál se aplicarán las funciones.

 + *Hardware:* se definen los pines en los que se conectan los elementos de hardware del sistema. Estos son:
   + *LCD:* pines conectados según:

     |------+------+------+-----+------+------+------|
     | RS   | E    | D4   | D5  | D6   | D7   | BL   |
     |------+------+------+-----+------+------+------|
     | PE13 | PF15 | PF13 | PE9 | PE11 | PF14 | PG14 |
     |------+------+------+-----+------+------+------|

   + *Pulsadores:* conectados en los siguientes pines:

     |-----+-----+-----+-----|
     | F1  | F2  | C1  | C2  |
     |-----+-----+-----+-----|
     | PC9 | PB8 | PC6 | PC8 |
     |-----+-----+-----+-----|

   + *RX USART:* Pin donde se conecta el receptor USART del módulo RF; correspondiente con =PA3=.
   + *TX USART:* Pin donde se conecta el transmisor USART del módulo RF; correspondiente con =PA2=.
   + *Baud Rate:* tasa de baudios en la que se dará la comunicación USART. Establecida como predeterminado en 9600 bd.

 + *Parámetros:* se definen variables de valor fijo que se utilizarán adelante en el código. Estas son:
   + *Longitud general buffers:* utilzada para definir la longitud fija de buffers para mostrar variables en el LCD.
   + *Agotamiento de cuenta del TIM3:* se setea a una frecuencia de 4 Hz, equivalente a 250 mseg.

#+begin_src c
/* * * * * * * * * * * * * CONSTANTES * * * * * * * * * * * * */
/* - - - -   LCD   - - - -*/
/*Constantes varias:*/
#define  TLCD_INIT_PAUSE        100000
#define  TLCD_PAUSE             50000
#define  TLCD_CLK_PAUSE         1000
#define  TLCD_MAXX              16
#define  TLCD_MAXY              2
#define  MaxDigCount            4095
#define  MaxMiliVoltRef         3320
#define  Res32Bit               32
#define  DAC_DHR12R2_ADDRESS    0x40007414
#define  TLCD_CMD_INIT_DISPLAY  0x28
#define  TLCD_CMD_ENTRY_MODE    0x06
#define  TLCD_CMD_DISP_M0       0x08
#define  TLCD_CMD_DISP_M1       0x0C
#define  TLCD_CMD_DISP_M2       0x0E
#define  TLCD_CMD_DISP_M3       0x0F
#define  TLCD_CMD_CLEAR         0x01

/*Identificacion pines:*/
typedef enum
{
  TLCD_RS = 0,  // RS-Pin
  TLCD_E  = 1,  // E-Pin
  TLCD_D4 = 2,  // DB4-Pin
  TLCD_D5 = 3,  // DB5-Pin
  TLCD_D6 = 4,  // DB6-Pin
  TLCD_D7 = 5   // DB7-Pin
}TLCD_NAME_t;

/*Nombre LCD:*/
#define  TLCD_ANZ   6

/*Estados LCD:*/
typedef enum {
  TLCD_OFF = 0,
  TLCD_ON,
  TLCD_CURSOR,
  TLCD_BLINK
}TLCD_MODE_t;

/*Crear LCD:*/
typedef struct {
  TLCD_NAME_t TLCD_NAME;
  GPIO_TypeDef* TLCD_PORT;
  const uint16_t TLCD_PIN;
  const uint32_t TLCD_CLK;
  BitAction TLCD_INIT;
}LCD_2X16_t;

/* - - - - HARDWARE - - - -*/
/*Definicion de pines del LCD:*/
LCD_2X16_t LCD_2X16[] = {
    /* Name  , PORT ,     PIN    ,         CLOCK       ,   Init    */
    { TLCD_RS, GPIOE, GPIO_Pin_13, RCC_AHB1Periph_GPIOE, Bit_RESET },
    { TLCD_E,  GPIOF, GPIO_Pin_15, RCC_AHB1Periph_GPIOF, Bit_RESET },
    { TLCD_D4, GPIOF, GPIO_Pin_13, RCC_AHB1Periph_GPIOF, Bit_RESET },
    { TLCD_D5, GPIOE, GPIO_Pin_9,  RCC_AHB1Periph_GPIOE, Bit_RESET },
    { TLCD_D6, GPIOE, GPIO_Pin_11, RCC_AHB1Periph_GPIOE, Bit_RESET },
    { TLCD_D7, GPIOF, GPIO_Pin_14, RCC_AHB1Periph_GPIOF, Bit_RESET },};

/*Pulsadores:*/
#define _F1 GPIOC
#define _f1 GPIO_Pin_9
#define _F2 GPIOB
#define _f2 GPIO_Pin_8
#define _C1 GPIOC
#define _c1 GPIO_Pin_6
#define _C2 GPIOC
#define _c2 GPIO_Pin_8

/*RX USART:*/
#define _RX GPIOA
#define _rx GPIO_Pin_3

/*TX USART:*/
#define _TX GPIOA
#define _tx GPIO_Pin_2

/*Baud Rate USART:*/
#define baudRate    9600

/* - - - - PARAMS. - - - -*/
/*Longitud general de buffers:*/
#define buffLen 20

/*Agotamiento de cuenta del TIM3:*/
#define freqTIM3 4
#+end_src
*** VARIABLES GLOBALES
Variables utilizadas en distintas subrutinas del código.

 + *EXTI:* parámetros que se corresponden con el manejo de interrupciones al pulso externo. Estas son:
   + *Switch temperatura:* se utiliza para indicar que se pulsó =S1=; solo puede tener dos estados lógicos (1 o 0).
   + *Switch servo:* se utiliza para indicar que se pulsó =S2=; solo puede tener dos estados lógicos (1 o 0).
   + *Switch SD:* se utiliza para indicar que se pulsó =S3=; solo puede tener dos estados lógicos (1 o 0).
   + *Switch extra:* se utiliza para indicar que se pulsó =S4=; solo puede tener dos estados lógicos (1 o 0).
 + *RF:* variables utilizadas en la transmisión de datos por módulos RF. Estas son:
   + *Temperatura en grados:* variable utilizada para guardar la conversión de la temperatura medida en forma digital en grados Celcius.
   + *Temperatura en valor digital:* variable utlizada para guardar el valor digitla de temperatura enviado por el SATDAC.
 + *LCD:* variables que se corresponden con el manejo de los mensajes mostrados en el LCD:
   + *Pantalla inicial:* variable utilizada para distinguir cuando se debe mostrar el mensaje inicial en el LCD. Comienza en estado alto debido a que ésta es la primer pantalla que ve cuando se enciende el sistema.
   + *Contador de 5 segundos:* variable utilizada para tomar el tiempo de los mensajes que tardan 5 segundos. Como la interrupción del TIM3 se da cada 250 mseg, se necesitará un valor de 20 en esta variable para comprobar que transcurrieron 5 segundos.

#+begin_src c
/* * * * * * * * * * * * * VAR. GLOBAL * * * * * * * * * * * * */
/* - - - -   EXTI   - - - -*/
/*Switch temperatura:*/
uint8_t switchTemp  = 0;

/*Switch SD:*/
uint8_t switchSD    = 0;

/*Switch servo:*/
uint8_t switchServo = 0;

/*Switch extra:*/
uint8_t switchMenu = 0;

/* - - - -   RF    - - - -*/
/*Temperatura en grados:*/
float tempDeg = 0;

/*Temperatura en valor digital:*/
uint32_t tempDig = 0;

/* - - - -   LCD   - - - -*/
/*Pantalla inicial:*/
uint8_t initialScreen = 1;

/*Contador de 5 segundos:*/
uint8_t fiveSecDelay = 0;
#+end_src

*** FUNCIONES LOCALES

En esta sección se definen los encabezados de las distintas funciones a utilizar en el código local:

 + *Parámetros LCD:* funciones utilizadas en el background para determinar varias cualidades del LCD. Son principalmente utilizadas por otras funciones para conseguir parámetros del LCD.
 + *Inicialización LCD:* función para inicializar los pines del LCD según el objeto /LCD_2X16/ definido a partir de los pines del hardware.
   + *Returns*: void.
   + *Params.*: Matriz tipo LCD_2X16_t con los pines detallados del LCD.
 + *Refrescar LCD:* función utilizada para reiniciar la pantalla del LCD. Normalmente se usa para actualizar los valores mostrados en pantalla.
   + *Returns*: void.
   + *Params.*: Matriz tipo LCD_2X16_t con los pines detallados del LCD.
 + *Imprimir LCD:* función utilizada para imprimir en el LCD una string introducida por el usuario.
   + *Returns*: void
   + *Params.*:
     + Matriz tipo LCD_2X16_t con los pines detallados del LCD.
     + Un indicador /x/ para indentificar la columna del LCD donde se iniciará la string.
     + Un indicardor /y/ para identificar la fila del LCD donde se iniciará la string.
     + Una string o puntero a la misma.
 + *Inicialización de salida digital:* se inicializa un pin del MCU como salida digital a través de su puerto y número de pin.
   + *Returns*: void
   + *Params.*: puerto y pin a inicializar.
 + *Inicialización TIM3:* función para incializar el TIM3 del MCU con una determinada frecuencia.
   + *Returns*: void.
   + *Params* : freq - Frecuencia en /[Hz]/ a la que se inicializará el TIM3.
 + *Configuración de interrupciones externas:* funciones utilizadas para habilitar las interrupciones externas; normalmente para interrumpir el MCU a través de entradas digitales.
   + *Inicialización EXTI:* se inicializa un pin del MCU para funcionar según la interrupción por entrada externa.
     + *Returns*: void.
     + *Params.*: Nombre del puerto y pin a configurar.
   + Las demás funciones **_EXTI_** se utilizan dentro de =INIT_EXTINT= para encontrar los parámetros correctos de los pines dados.
 + *Inicialización puertos USART:* inicializa pines como receptor y transmisor USART. El pin seleccionado debe estar especificado como receptor  o transmisor USART respectivamente para ser configurado correctamente.
   + *Returns*: void.
   + *Params.*: Nombre del puerto y pin a configurar; especificar el =baud rate= al que se establece la conexión.
   + *Funciones de acción de los pulsadores:* utilizadas para realizar las diferentes acciones que dictan los pulsadores. Estas son:
     + Pedido de la temperatura al SATDAC mediante el receptor USART.
     + Envió del comando para mover la antena en el SATDAC mediante el transmisor USART.
     + Guardado de datos en la memoria SD.
 + *Encontrar PinSource:* función secundaria utilizada para establecer el =PinSource= de un determinado Pin.
   + *Returns*: =uint8_t= con el =PinSource= del Pin dado.
   + *Params.*: nombre del Pin a encontrar.
 + *Encontrar CLOCK:* función utilizada para definir el CLOCK correspondiente a un determinado puerto en las funciones.
   + *Returns*: /uint32_t/ con el dato del CLOCK.
   + *Params.*: Nombre del puerto a determinar.

#+begin_src c
/* * * * * * * * * * * * * FUNCIONES * * * * * * * * * * * * */
/*Parametros LCD:*/
void P_LCD_2x16_InitIO(LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_PinLo(TLCD_NAME_t lcd_pin, LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_PinHi(TLCD_NAME_t lcd_pin, LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_Delay(volatile uint32_t nCount);
void P_LCD_2x16_InitSequenz(LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_Clk(LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_Cmd(uint8_t wert, LCD_2X16_t* LCD_2X16);
void P_LCD_2x16_Cursor(LCD_2X16_t* LCD_2X16, uint8_t x, uint8_t y);
void P_LCD_2x16_Data(uint8_t wert, LCD_2X16_t* LCD_2X16);

/*Inicializacion LCD:*/
void INIT_LCD_2x16(LCD_2X16_t* LCD_2X16);

/*Refrescar LCD:*/
void CLEAR_LCD_2x16(LCD_2X16_t* LCD_2X16);

/*Imprimir LCD:*/
void PRINT_LCD_2x16(LCD_2X16_t* LCD_2X16, uint8_t x, uint8_t y, char *ptr);

/*Inicializacion de salida digital:*/
void INIT_DO(GPIO_TypeDef* Port, uint32_t Pin);

/*Inicializacion TIM3:*/
void INIT_TIM3(uint32_t freq);

/*Configuracion de nterrupciones externas:*/
void INIT_EXTINT(GPIO_TypeDef* Port, uint16_t Pin);
uint8_t FIND_EXTI_PORT_SOURCE(GPIO_TypeDef* Port);
uint8_t FIND_EXTI_PIN_SOURCE(uint32_t Pin);
uint32_t FIND_EXTI_LINE(uint32_t Pin);
uint32_t FIND_EXTI_HANDLER(uint32_t Pin);

/*Inicialización puertos USART:*/
void INIT_USART_RX_TX(GPIO_TypeDef* Port1, uint16_t Pin1, GPIO_TypeDef* Port2, uint16_t Pin2, uint32_t BaudRate);

/*Funciones de accion de los pulsadores:*/
void TEMP(void);
void SERVO(void);
void SD(void);

/*Encontrar PinSource:*/
uint8_t FIND_PINSOURCE(uint32_t Pin);

/*Encontrar CLOCK:*/
uint32_t FIND_CLOCK(GPIO_TypeDef* Port);
#+end_src

** MAIN
En esta parte se encuentra la sección principal del código donde se inicializa y se llama a las funciones. Además, se realizan diferentes procesamientos en el bucle principal.

#+begin_src c
/*----------------------------------------------------------------*/
/*MAIN:                                                           */
/*----------------------------------------------------------------*/
int main(void){
#+end_src

*** INICIALIZACION

En esta sección se inicializan las diferentes componentes del código. Este el procesamiento inicial que se realiza cuando se enciende el sistema.

Las funciones llamadas para inicializar son las siguientes:
 + *Inicio del sistema:* función general de las librerías estándar para inicializar las funciones del MCU.
 + *Inicialización del TIM3:* se configura a partir de una interrupción cada 250 mseg según =freqTIM3=. Se utiliza para controlar el refresco del LCD; y toda la lógica se puede encontrar en el handler de la interrupción al vencimiento =void TIM3_IRQHandler(void)=.
 + *Inicialización de interrupciones por pulso externo:* se inicializan los cuatro pulsadores conectados en forma matricial. Los pulsadores C1 y C2 se inicialización como entradas (con interrupción); y los pulsadores F1 y F2 como salidas. De esta forma, se alterna el pulso alto en F1 y F2 para evaluar constantemente el estado de C1 y C2. Adicionalmente, se setea F1 (arbitrariamente) para que arranque con un valor distinto de F2.

#+begin_src c
/* * * * * * * * * * * * * INICIALIZ. * * * * * * * * * * * * */
    /*Inicio del sistema:*/
    SystemInit();

    /*Inicializacion del TIM3:*/
    INIT_TIM3(freqTIM3);

    /*Inicializacion interrupciones por pulso externo:*/
    INIT_EXTINT(_C1,_c1);
    INIT_EXTINT(_C2,_c2);
    INIT_DO(_F1,_f1);
    INIT_DO(_F2,_f2);
    GPIO_SetBits(_F1, _f1);
#+end_src

*** BUCLE PPAL.:

Esta sección muestra el bucle principal infinito del código:

#+begin_src c
/* * * * * * * * * * * * * BUCLE PPAL. * * * * * * * * * * * * */
  while (1)
  {
      if     (switchTemp == 1)  TEMP();
      else if(switchSD == 1)    SD();
      else if(switchServo == 1) SERVO();
  }
}
#+end_src

** INTERRUPCIONES
#+begin_src c
/*----------------------------------------------------------------*/
/*INTERRUPCIONES:                                                 */
/*----------------------------------------------------------------*/
#+end_src
*** TIM3 / LCD
Esta interrupción se utiliza principalmente para actualizar los valores del LCD y refrescar distintos parámetros y variables globales del código. En la configuración está seteada para que el agotamiento de cuenta se de cada 250 mseg.

La pantalla inicial del LCD se ve de la siguiente forma:

|---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
|---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|
|   |   | T | D |   | I | I | - | E | R | D  |  Y | T  | C  |    |    |
|   |   | T | e | m | p | = | X | X | . | X  |    | °  | C  |    |    |
|---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|

Donde las =XX.X= indican el valor de temperatura inicial leído con un dígito de confianza. Cuando se enciende el dispositivo por primera vez, el valor mostrado será incorrecto; el mismo se actualizará cuando se presione el pulsador =S1= para pedir la temperatura al SATDAC.

Luego, al presionar los diferentes pulsadores se verán distintas pantallas:

**** Pulsador S1
Aparecerá en el LCD un mensaje para indicar que se confirma el pedido de temperatura. El mismo dura 5 segundos.

|---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
|---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|
|   |   | T | E | M | P | E | R | A | T | U  | R  | A  |    |    |    |
|   |   | A | C | T | U | A | L | I | Z | A  | D  | A  |    |    |    |
|---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|

Luego, el sistema volverá a la pantalla inicial con el valor de temperatura actualizado.

**** Pulsador S2
Cuando se pulsa S2, aparecerá un mensaje en el LCD por 5 segundos indicando que los datos fueron guardados en la memoria SD:

|---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
|---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|
|   | D | A | T | O | S |   | G | U | A | R  | D  | A  | D  | O  |  S |
|   |   | C | O | R | R | E | C | T | A | M  | E  | N  | T  | E  |    |
|---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|

Luego, el sistema volverá a la pantalla inicial.

**** Pulsador S3
Cuando se pulsa S3, aparecerá un mensaje en el LCD indicando que el proceso de mover la antena en el SATDAC se está iniciando:

|---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
|---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|
| A | N | T | E | N | A |   | D | E | S | P  | L  | E  | G  | A  |    |
|   |   | C | O | R | R | E | C | T | A | M  | E  | N  | T  | E  |    |
|---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|

Luego de 5 segundos, el sistema vuelve a la pantalla inicial.
**** Pulsador S4
Cuando se pulsa S4, el LCD cambiará a una pantalla secuandaria donde se indica la función de cada pulsador:

|---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|
| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 |
|---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|
| 1 | _ | T | e | m | p | . |   |   | 3 | _  | S  | e  | r  | v  | o  |
| 2 | _ | S | D |   |   |   |   |   | 4 | _  | V  | o  | l  | v  | e  |
|---+---+---+---+---+---+---+---+---+---+----+----+----+----+----+----|

El sistema volverá a la pantalla inicial si se vuelve a presionar el pulsador =S4=.
**** Código

Se implementan cada uno de los mensajes mostrados anterioremente a partir de la interrupción por agotamiento de cuenta del TIM3 cada 250 mseg:

#+begin_src c
/*Interrupcion por vencimiento de cuenta de TIM3 cada 1/FS:*/
void TIM3_IRQHandler(void) {
    if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) {

        /*Buffer para mostrar el valor de temperatura:*/
        char BuffTemp[buffLen];

        /*Refresco LCD:*/
        CLEAR_LCD_2x16(LCD_2X16);

        /*Pantalla incial:*/
        if(initialScreen == 1){
            /*Algoritmo para mostrar el mensaje:*/
            PRINT_LCD_2x16(LCD_2X16, 2, 0, "TD II-ERDYTC");
            sprintf(BuffTemp, "%.1f", tempDeg);
            PRINT_LCD_2x16(LCD_2X16, 2, 1, "Temp=");
            PRINT_LCD_2x16(LCD_2X16, 7, 1, BuffTemp);
        }

        /*Pantalla actualizar temperatura - pulsador S1:*/
        else if(switchTemp == 1 && fiveSecDelay <= 20){
            /*Aumentar el contador de los 5 seg:*/
            fiveSecDelay++;

            /*Algoritmo para mostrar el mensaje:*/
            PRINT_LCD_2x16(LCD_2X16, 2, 0, "TEMPERATURA");
            PRINT_LCD_2x16(LCD_2X16, 2, 1, "ACTUALIZADA");
        }

        /*Pantalla SD - pulsador S2:*/
        else if(switchSD == 1 && fiveSecDelay <= 20){
            /*Aumentar el contador de los 5 seg:*/
            fiveSecDelay++;

            /*Algoritmo para mostrar el mensaje:*/
            PRINT_LCD_2x16(LCD_2X16, 1, 0, "DATOS GUARDADOS");
            PRINT_LCD_2x16(LCD_2X16, 2, 1, "CORRECTAMENTE");
        }

        /*Pantalla mover servo - pulsador S3:*/
        else if(switchServo == 1 && fiveSecDelay <= 20){
            /*Aumentar el contador de los 5 seg:*/
            fiveSecDelay++;

            /*Algoritmo para mostrar el mensaje:*/
            PRINT_LCD_2x16(LCD_2X16, 0, 0, "ANTENA DESPLEGA");
            PRINT_LCD_2x16(LCD_2X16, 2, 1, "CORRECTAMENTE");
        }

        /*Pantalla menu - pulsador S4:*/
        else if(switchMenu == 1 && fiveSecDelay <= 20){
            /*Aumentar el contador de los 5 seg:*/
            fiveSecDelay++;

            /*Algoritmo para mostrar el mensaje:*/
            PRINT_LCD_2x16(LCD_2X16, 0, 0, "1_Temp.");
            PRINT_LCD_2x16(LCD_2X16, 9, 0, "3_Servo");
            PRINT_LCD_2x16(LCD_2X16, 0, 1, "2_SD");
            PRINT_LCD_2x16(LCD_2X16, 9, 1, "4_Volver");
        }

        /*Reseteo variables:*/
        else{
            initialScreen   = 1;
            switchTemp      = 0;
            switchSD        = 0;
            switchServo     = 0;
            switchMenu      = 0;
        }

        /*Rehabilitacion del timer:*/
        TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
    }
}
#+end_src

*** EXTI
El objetivo de los pulsadores es realizar una acción distinta sobre el Cubesat por cada uno. En la ERDYTC, cada acción se mostrará en el LCD. A los pulsadores se los llamará =S1,...,S4= respectivamente, y cada acción se distinguirá en las siguientes categorías:
 + =switchTemp= iniciará la transmisión de datos desde el SATDAC y actualizará el valor de temperatura mostrado en la ERDYT. Se corresponde con =S1=.
 + =switchServo= iniciará el desplazamiento o contracción de la antena de transmisión del Cubesat dependiendo de su estado anterior. Se corresponde con =S2=.
 + =switchSD= iniciará el proceso de guardado de datos en memoria SD de la ERDYTC. Se corresponde con =S3=.
 + =switchMenu= todavía tenemos que decidir que hace :TODO:.

La rutina de interrupción se basa en el hecho de que los pulsadores están conectados de forma matricial. Debido a esto, dos de los pulsadores intercalan un estado alto (=F1= y =F2=), mientras que se lee en los otros dos (=C1= y =C2=) cuál está en estado alto. Con ésta lógica, se puede interpretar que switch se pulsó de la siguiente manera:

                       |----------+----------+----------|
                       |          | *C1 = 1* | *C2 = 1* |
                       |----------+----------+----------|
                       | *F1 = 1* | S1 = 1   | S3 = 1   |
                       | *F2 = 1* | S2 = 1   | S4 = 1   |
                       |----------+----------+----------|

Finalmente, se pone en estado bajo la variable =initalScreen= para evitar que el programa ingrese a la subrutina para mostrar la pantalla inicial y en cambio muestre las pantallas correspondientes al pulsador apretado.

#+begin_src c
/*Interrupcion al pulso por PC6-C1 o PC8-C2:*/
void EXTI9_5_IRQHandler(void)
{
  /*Si la interrupcion fue por linea 6 (PC6 - C1):*/
  if(EXTI_GetITStatus(EXTI_Line6) != RESET){
      /*Si ademas de estar C1 en 1 tambien esta F1 en 1, entonces el switch pulsado es S1:*/
      if(GPIO_ReadInputDataBit(_F1, _f1))       switchTemp = 1;
      /*Si ademas de estar C1 en 1 tambien esta F2 en 1, entonces el switch pulsado es S2:*/
      else if(GPIO_ReadInputDataBit(_F2, _f2))  switchSD = 1;

      /*Clear the EXTI line 6 pending bit:*/
      EXTI_ClearITPendingBit(EXTI_Line6);
  }

  /*Si la interrupcion fue por linea 8 (PC8 - C2):*/
  else if(EXTI_GetITStatus(EXTI_Line8) != RESET){
      /*Si ademas de estar C2 en 1 tambien esta F1 en 1, entonces el switch pulsado es S3:*/
      if (GPIO_ReadInputDataBit(_F1, _f1))      switchServo = 1;
      /*Si ademas de estar C2 en 1 tambien esta F2 en 1, entonces el switch pulsado es S4:*/
      else if (GPIO_ReadInputDataBit(_F2, _f2)) switchMenu = 1;

      /*Clear the EXTI line 8 pending bit:*/
      EXTI_ClearITPendingBit(EXTI_Line8);
  }

  /*Evitar que se muestre la pantalla incial:*/
  initialScreen = 0;
}
#+end_src
** FUNCIONES LOCALES
En esta sección se implementan las diferentes funciones del código.

#+begin_src c
/*----------------------------------------------------------------*/
/*FUNCIONES LOCALES:                                              */
/*----------------------------------------------------------------*/
#+end_src
*** General
#+begin_src c
/* * * * * * * * * * * * * GENERAL * * * * * * * * * * * * */
#+end_src
**** Inicialización de salida digital

#+begin_src c
void INIT_DO(GPIO_TypeDef* Port, uint32_t Pin)
{
    /*Estructura de configuracion:*/
    GPIO_InitTypeDef GPIO_InitStructure;

    /*Habilitacion de la senal de reloj para el periferico:*/
    RCC_AHB1PeriphClockCmd(FIND_CLOCK(Port), ENABLE);

    /*Se configura el pin como entrada (GPI0_MODE_IN):*/
    GPIO_InitStructure.GPIO_Pin = Pin;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;

    /*Se aplica la configuracion definida anteriormente al puerto:*/
    GPIO_Init(Port, &GPIO_InitStructure);
}
#+end_src

**** Encontrar CLOCK
#+begin_src c
uint32_t FIND_CLOCK(GPIO_TypeDef* Port)
{
    uint32_t Clock;

    if      (Port == GPIOA) Clock = RCC_AHB1Periph_GPIOA;
    else if (Port == GPIOB) Clock = RCC_AHB1Periph_GPIOB;
    else if (Port == GPIOC) Clock = RCC_AHB1Periph_GPIOC;
    else if (Port == GPIOD) Clock = RCC_AHB1Periph_GPIOD;
    else if (Port == GPIOE) Clock = RCC_AHB1Periph_GPIOE;
    else if (Port == GPIOF) Clock = RCC_AHB1Periph_GPIOF;
    else if (Port == GPIOG) Clock = RCC_AHB1Periph_GPIOG;
    return Clock;
}
#+end_src
*** TIMERS
#+begin_src c
/* * * * * * * * * * * * * TIMERS * * * * * * * * * * * * */
#+end_src
**** Inicialización TIM3

#+begin_src c
/*Inicializacion del TIM3:*/
void INIT_TIM3(uint32_t Freq)
{

    /*Habilitacion del clock para el TIM3:*/
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);

    /*Habilitacion de la interrupcion por agotamiento de cuenta del TIM3:*/
    NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);

    /*Actualización de los valores del TIM3:*/
    SystemCoreClockUpdate();
    TIM_ITConfig(TIM3, TIM_IT_Update, DISABLE);
    TIM_Cmd(TIM3, DISABLE);

    /*Definicion de la base de tiempo:*/
    uint32_t TimeBase = 200e3;

    /*Computar el valor del preescaler en base a la base de tiempo:*/
    uint16_t PrescalerValue = 0;
    PrescalerValue = (uint16_t) ((SystemCoreClock / 2) / TimeBase) - 1;

    /*Configuracion del tiempo de trabajo en base a la frecuencia:*/
    TIM_TimeBaseStructure.TIM_Period = TimeBase / Freq - 1;
    TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
    TIM_TimeBaseStructure.TIM_ClockDivision = 0;
    TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;

    TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);

    /*Habilitacion de la interrupcion:*/
    TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);

    /*Habilitacion del contador:*/
    TIM_Cmd(TIM3, ENABLE);
}
#+end_src

*** EXTI
#+begin_src c
/* * * * * * * * * * * * * EXTI * * * * * * * * * * * * */
#+end_src
**** Habilitación de pin EXTI
#+begin_src c
void INIT_EXTINT(GPIO_TypeDef* Port, uint16_t Pin)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    NVIC_InitTypeDef NVIC_InitStructure;

    /*Enable GPIO clock:*/
    uint32_t Clock;
    Clock = FIND_CLOCK(Port);
    RCC_AHB1PeriphClockCmd(Clock, ENABLE);
    /* Enable SYSCFG clock */
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

    /* Configure pin as input floating */
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_Pin = Pin;
    GPIO_Init(Port, &GPIO_InitStructure);

    /* Connect EXTI Line to pin */
    SYSCFG_EXTILineConfig(FIND_EXTI_PORT_SOURCE(Port), FIND_EXTI_PIN_SOURCE(Pin));

    /* Configure EXTI Line0 */
    EXTI_InitStructure.EXTI_Line = FIND_EXTI_LINE(Pin);
    EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising;
    EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    EXTI_Init(&EXTI_InitStructure);

    /* Enable and set EXTI Line0 Interrupt to the lowest priority */
    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    NVIC_InitStructure.NVIC_IRQChannel = FIND_EXTI_HANDLER(Pin);
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0x03;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0x03;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
}
#+end_src
**** Encontrar port source EXTI
#+begin_src c
uint8_t FIND_EXTI_PORT_SOURCE(GPIO_TypeDef* Port)
{
    if (Port == GPIOA)      return EXTI_PortSourceGPIOA;
    else if (Port == GPIOB) return EXTI_PortSourceGPIOB;
    else if (Port == GPIOC) return EXTI_PortSourceGPIOC;
    else if (Port == GPIOD) return EXTI_PortSourceGPIOD;
    else if (Port == GPIOE) return EXTI_PortSourceGPIOE;
    else if (Port == GPIOF) return EXTI_PortSourceGPIOF;
    else                    return 0;
}
#+end_src
**** Encontrar pin source EXTI
#+begin_src c
uint8_t FIND_EXTI_PIN_SOURCE(uint32_t Pin)
{
    if (Pin == GPIO_Pin_0)          return EXTI_PinSource0;
    else if (Pin == GPIO_Pin_1)     return EXTI_PinSource1;
    else if (Pin == GPIO_Pin_1)     return EXTI_PinSource1;
    else if (Pin == GPIO_Pin_2)     return EXTI_PinSource2;
    else if (Pin == GPIO_Pin_3)     return EXTI_PinSource3;
    else if (Pin == GPIO_Pin_4)     return EXTI_PinSource4;
    else if (Pin == GPIO_Pin_5)     return EXTI_PinSource5;
    else if (Pin == GPIO_Pin_6)     return EXTI_PinSource6;
    else if (Pin == GPIO_Pin_7)     return EXTI_PinSource7;
    else if (Pin == GPIO_Pin_8)     return EXTI_PinSource8;
    else if (Pin == GPIO_Pin_9)     return EXTI_PinSource9;
    else if (Pin == GPIO_Pin_10)    return EXTI_PinSource10;
    else if (Pin == GPIO_Pin_11)    return EXTI_PinSource11;
    else if (Pin == GPIO_Pin_12)    return EXTI_PinSource12;
    else if (Pin == GPIO_Pin_13)    return EXTI_PinSource13;
    else if (Pin == GPIO_Pin_14)    return EXTI_PinSource14;
    else                            return 0;
}
#+end_src
**** Encontrar EXTI line
#+begin_src c
uint32_t FIND_EXTI_LINE(uint32_t Pin)
{
    if (Pin == GPIO_Pin_0)          return EXTI_Line0;
    else if (Pin == GPIO_Pin_1)     return EXTI_Line1;
    else if (Pin == GPIO_Pin_2)     return EXTI_Line2;
    else if (Pin == GPIO_Pin_3)     return EXTI_Line3;
    else if (Pin == GPIO_Pin_4)     return EXTI_Line4;
    else if (Pin == GPIO_Pin_5)     return EXTI_Line5;
    else if (Pin == GPIO_Pin_6)     return EXTI_Line6;
    else if (Pin == GPIO_Pin_7)     return EXTI_Line7;
    else if (Pin == GPIO_Pin_8)     return EXTI_Line8;
    else if (Pin == GPIO_Pin_9)     return EXTI_Line9;
    else if (Pin == GPIO_Pin_10)    return EXTI_Line10;
    else if (Pin == GPIO_Pin_11)    return EXTI_Line11;
    else if (Pin == GPIO_Pin_12)    return EXTI_Line12;
    else if (Pin == GPIO_Pin_13)    return EXTI_Line13;
    else if (Pin == GPIO_Pin_14)    return EXTI_Line14;
    else if (Pin == GPIO_Pin_15)    return EXTI_Line15;
    else                            return 0;
}
#+end_src
**** Encontrar EXTI handler
#+begin_src c
uint32_t FIND_EXTI_HANDLER(uint32_t Pin)
{
    if (Pin == GPIO_Pin_0)          return EXTI0_IRQn;
    else if (Pin == GPIO_Pin_1)     return EXTI1_IRQn;
    else if (Pin == GPIO_Pin_2)     return EXTI2_IRQn;
    else if (Pin == GPIO_Pin_3)     return EXTI3_IRQn;
    else if (Pin == GPIO_Pin_4)     return EXTI4_IRQn;
    else if (Pin == GPIO_Pin_5  ||
             Pin == GPIO_Pin_5  ||
             Pin == GPIO_Pin_7  ||
             Pin == GPIO_Pin_8  ||
             Pin == GPIO_Pin_9)     return EXTI9_5_IRQn;
    else if (Pin == GPIO_Pin_10 ||
             Pin == GPIO_Pin_11 ||
             Pin == GPIO_Pin_12 ||
             Pin == GPIO_Pin_13 ||
             Pin == GPIO_Pin_14 ||
             Pin == GPIO_Pin_15)    return EXTI15_10_IRQn;
    else                            return 0;
}
#+end_src
*** USART
#+begin_src c
/* * * * * * * * * * * * * USART * * * * * * * * * * * * */
#+end_src
**** Inicialización de puertos USART
La configuración del Pin USART se da como sigue:

 + =Baud Rate= especificado por el usario; aunque se utiliza 9600 bd como default.
 + Largo de palabra de 8 bits.
 + 1 bit de stop.
 + Sin paridad.
 + Control de flujo por hardware deshabilitado (señales RTS y CTS).
 + Recepción y transmisión habilitadas.

#+begin_src c
void INIT_USART_RX_TX(GPIO_TypeDef* Port1, uint16_t Pin1, GPIO_TypeDef* Port2, uint16_t Pin2, uint32_t BaudRate)
{
    /*USART clock enable:*/
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);

    /*GPIO clock enable:*/
    RCC_AHB1PeriphClockCmd(FIND_CLOCK(Port1), ENABLE);
    RCC_AHB1PeriphClockCmd(FIND_CLOCK(Port2), ENABLE);

    /*GPIO Configuration:*/
    GPIO_InitTypeDef GPIO_InitStructure;

    GPIO_InitStructure.GPIO_Pin = Pin1;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(Port1, &GPIO_InitStructure);

    GPIO_InitStructure.GPIO_Pin = Pin2;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_Init(Port2, &GPIO_InitStructure);

    /*Connect USART pins to AF:*/
    GPIO_PinAFConfig(Port1, FIND_PINSOURCE(Pin1), GPIO_AF_USART2);
    GPIO_PinAFConfig(Port2, FIND_PINSOURCE(Pin2), GPIO_AF_USART2);

    /*USARTx configuration:*/
    USART_InitTypeDef USART_InitStructure;

    USART_InitStructure.USART_BaudRate = BaudRate;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;

    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

    USART_Init(USART2, &USART_InitStructure);

    USART_Cmd(USART2, ENABLE);
}
#+end_src
**** Recepción de temperatura
Esta función utiliza el recpetor USART RF para obtener el parámetro de temperatura entregado por el SATDAC.

La temperatura dada en forma digital se almacena en la variable =tempDig=.

Al finalizar la operación se resetea el flag =switchTemp= para entrar a la subrutina.

#+begin_src c
void TEMP(void){
    /*Mientras se reciba un dato:*/
    while (USART_GetFlagStatus(USART2, USART_FLAG_RXNE) != RESET){
        /*Se guarda lo recibido en forma digital:*/
        tempDig = USART_ReceiveData(USART2);
    }
}
#+end_src
**** Transmisión comando antena
Esta función se encarga de transmitir el comando necesario para inciar el movimiento del servomotor en el SATDAC:

#+begin_src c
void SERVO(void){

    /*Creacion de la variable para desplegar la antena:*/
    uint8_t servoON = 1;

    /*Clarear el flag de estado para transmitir:*/
    while (USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET)
    {}

    /*Iniciar la transmision:*/
    USART_SendData(USART2, servoON);
}
#+end_src
*** SD
#+begin_src c
/* * * * * * * * * * * * * SD * * * * * * * * * * * * */
#+end_src

Uso de la SD??????

#+begin_src c
void SD(void){

}
#+end_src

*** LCD
#+begin_src c
/* * * * * * * * * * * * * LCD * * * * * * * * * * * * */
#+end_src

Luego, se definen las funciones activas que se utilizarán en la parte de funcionalidad del código. Estas son:

 + Incialización de los pines del LCD.
 + Refresco de la pantalla del LCD.
 + Impresión en la pantalla del LCD.

#+begin_src c
/*Inicializacion de los pines del LCD:*/
void INIT_LCD_2x16(LCD_2X16_t* LCD_2X16)
{
    //Inicialización de los pines del LCD:
    P_LCD_2x16_InitIO(LCD_2X16);
    // kleine Pause
    P_LCD_2x16_Delay(TLCD_INIT_PAUSE);
    // Init Sequenz starten
    P_LCD_2x16_InitSequenz(LCD_2X16);
    // LCD-Settings einstellen
    P_LCD_2x16_Cmd(TLCD_CMD_INIT_DISPLAY, LCD_2X16);
    P_LCD_2x16_Cmd(TLCD_CMD_ENTRY_MODE, LCD_2X16);
    // Display einschalten
    P_LCD_2x16_Cmd(TLCD_CMD_DISP_M1, LCD_2X16);
    // Display l�schen
    P_LCD_2x16_Cmd(TLCD_CMD_CLEAR, LCD_2X16);
    // kleine Pause
    P_LCD_2x16_Delay(TLCD_PAUSE);
}

/*Refresco de la pantalla del LCD:*/
void CLEAR_LCD_2x16(LCD_2X16_t* LCD_2X16)
{
  // Display l�schen
  P_LCD_2x16_Cmd(TLCD_CMD_CLEAR, LCD_2X16);
  // kleine Pause
  P_LCD_2x16_Delay(TLCD_PAUSE);
}

/*Impresion en la pantalla del LCD:*/
void PRINT_LCD_2x16(LCD_2X16_t* LCD_2X16, uint8_t x, uint8_t y, char *ptr)
{
  // Cursor setzen
  P_LCD_2x16_Cursor(LCD_2X16,x,y);
  // kompletten String ausgeben
  while (*ptr != 0) {
    P_LCD_2x16_Data(*ptr, LCD_2X16);
    ptr++;
  }
}
#+end_src
Primero se definen las funciones internas del LCD que se utilizan luego en las funciones activas. Estas son:

 + Inicialización de los pines del LCD.
 + Cambio de estados del LCD, para modificar un bit a alto o bajo.
 + Retardo del LCD, utilizado solamente en funciones específicas del LCD.
 + Inicialización secuencias LCD.
 + Configuración del CLOCK del LCD.
 + Definición de comandos del LCD.
 + Análisis de datos del LCD.

#+begin_src c
/* * * * * * * * * * * * *     LCD    * * * * * * * * * * * * */
/*Inicializacion pines LCD:*/
void P_LCD_2x16_InitIO(LCD_2X16_t* LCD_2X16)
{
    GPIO_InitTypeDef GPIO_InitStructure;
    TLCD_NAME_t lcd_pin;

    for (lcd_pin = 0; lcd_pin < TLCD_ANZ; lcd_pin++)
    {
        //Habilitacion del Clock para cada PIN:
        RCC_AHB1PeriphClockCmd(LCD_2X16[lcd_pin].TLCD_CLK, ENABLE);

        //Configuracion como salidas digitales:
        GPIO_InitStructure.GPIO_Pin = LCD_2X16[lcd_pin].TLCD_PIN;
        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
        GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
        GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
        GPIO_Init(LCD_2X16[lcd_pin].TLCD_PORT, &GPIO_InitStructure);

        //Default Wert einstellen
        if(LCD_2X16[lcd_pin].TLCD_INIT == Bit_RESET)
            P_LCD_2x16_PinLo(lcd_pin, LCD_2X16);
        else
            P_LCD_2x16_PinHi(lcd_pin, LCD_2X16);
    }
}

/*Cambio de estados del LCD:*/
void P_LCD_2x16_PinLo(TLCD_NAME_t lcd_pin, LCD_2X16_t* LCD_2X16)
{
  LCD_2X16[lcd_pin].TLCD_PORT->BSRRH = LCD_2X16[lcd_pin].TLCD_PIN;
}

void P_LCD_2x16_PinHi(TLCD_NAME_t lcd_pin, LCD_2X16_t* LCD_2X16)
{
  LCD_2X16[lcd_pin].TLCD_PORT->BSRRL = LCD_2X16[lcd_pin].TLCD_PIN;
}

/*Retardo LCD:*/
void P_LCD_2x16_Delay(volatile uint32_t nCount)
{
  while(nCount--)
  {
  }
}

/*Inicializacion secuencia LCD:*/
void P_LCD_2x16_InitSequenz(LCD_2X16_t* LCD_2X16)
{
  //Inicializacion de la secuencia:
  P_LCD_2x16_PinHi(TLCD_D4, LCD_2X16);
  P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16);
  P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  // Erster Init Impuls
  P_LCD_2x16_Clk(LCD_2X16);
  P_LCD_2x16_Delay(TLCD_PAUSE);
  // Zweiter Init Impuls
  P_LCD_2x16_Clk(LCD_2X16);
  P_LCD_2x16_Delay(TLCD_PAUSE);
  // Dritter Init Impuls
  P_LCD_2x16_Clk(LCD_2X16);
  P_LCD_2x16_Delay(TLCD_PAUSE);
  // LCD-Modus einstellen (4Bit-Mode)
  P_LCD_2x16_PinLo(TLCD_D4, LCD_2X16);
  P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16);
  P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  P_LCD_2x16_Clk(LCD_2X16);
  P_LCD_2x16_Delay(TLCD_PAUSE);
}

/*Configuracion CLOCK LCD:*/
void P_LCD_2x16_Clk(LCD_2X16_t* LCD_2X16)
{
  // Pin-E auf Hi
  P_LCD_2x16_PinHi(TLCD_E, LCD_2X16);
  // kleine Pause
  P_LCD_2x16_Delay(TLCD_CLK_PAUSE);
  // Pin-E auf Lo
  P_LCD_2x16_PinLo(TLCD_E, LCD_2X16);
  // kleine Pause
  P_LCD_2x16_Delay(TLCD_CLK_PAUSE);
}

/*Comandos LCD:*/
void P_LCD_2x16_Cmd(uint8_t wert, LCD_2X16_t* LCD_2X16)
{
  // RS=Lo (Command)
  P_LCD_2x16_PinLo(TLCD_RS, LCD_2X16);
  // Hi-Nibble ausgeben
  if((wert&0x80)!=0) P_LCD_2x16_PinHi(TLCD_D7, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  if((wert&0x40)!=0) P_LCD_2x16_PinHi(TLCD_D6, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  if((wert&0x20)!=0) P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D5, LCD_2X16);
  if((wert&0x10)!=0) P_LCD_2x16_PinHi(TLCD_D4, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D4, LCD_2X16);
  P_LCD_2x16_Clk(LCD_2X16);
  // Lo-Nibble ausgeben
  if((wert&0x08)!=0) P_LCD_2x16_PinHi(TLCD_D7, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  if((wert&0x04)!=0) P_LCD_2x16_PinHi(TLCD_D6, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  if((wert&0x02)!=0) P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D5, LCD_2X16);
  if((wert&0x01)!=0) P_LCD_2x16_PinHi(TLCD_D4, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D4, LCD_2X16);
  P_LCD_2x16_Clk(LCD_2X16);
}

void P_LCD_2x16_Cursor(LCD_2X16_t* LCD_2X16, uint8_t x, uint8_t y)
{
  uint8_t wert;

  if(x>=TLCD_MAXX) x=0;
  if(y>=TLCD_MAXY) y=0;

  wert=(y<<6);
  wert|=x;
  wert|=0x80;
  P_LCD_2x16_Cmd(wert,LCD_2X16);
}

/*Analisis de datos LCD:*/
void P_LCD_2x16_Data(uint8_t wert, LCD_2X16_t* LCD_2X16)
{
  // RS=Hi (Data)
  P_LCD_2x16_PinHi(TLCD_RS, LCD_2X16);
  // Hi-Nibble ausgeben
  if((wert&0x80)!=0) P_LCD_2x16_PinHi(TLCD_D7, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  if((wert&0x40)!=0) P_LCD_2x16_PinHi(TLCD_D6, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  if((wert&0x20)!=0) P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D5, LCD_2X16);
  if((wert&0x10)!=0) P_LCD_2x16_PinHi(TLCD_D4, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D4, LCD_2X16);
  P_LCD_2x16_Clk(LCD_2X16);
  // Lo-Nibble ausgeben
  if((wert&0x08)!=0) P_LCD_2x16_PinHi(TLCD_D7, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D7, LCD_2X16);
  if((wert&0x04)!=0) P_LCD_2x16_PinHi(TLCD_D6, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D6, LCD_2X16);
  if((wert&0x02)!=0) P_LCD_2x16_PinHi(TLCD_D5, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D5, LCD_2X16);
  if((wert&0x01)!=0) P_LCD_2x16_PinHi(TLCD_D4, LCD_2X16); else P_LCD_2x16_PinLo(TLCD_D4, LCD_2X16);
  P_LCD_2x16_Clk(LCD_2X16);
}
#+end_src
