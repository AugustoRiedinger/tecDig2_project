#+TITLE: Sistema de adquisición de datos y lógica digital base para implementación en CubeSats
#+AUTHOR: A. Riedinger & G. Garcia
#+PROPERTY: header-args :tangle src/main.c

* Índice :toc:
- [[#sobre-el-proyecto][Sobre el proyecto:]]
- [[#satdac][SATDAC:]]
  - [[#librerias-utilizadas][Librerias utilizadas:]]
  - [[#estructuras][Estructuras:]]
  - [[#definición-de-constantes][Definición de constantes:]]
  - [[#definición-de-funciones-locales][Definición de funciones locales:]]
  - [[#main][Main:]]
  - [[#funciones-locales][Funciones locales:]]

* Sobre el proyecto:

El objetivo del proyecto es construir la base lógica digital inicial, como *prueba de concepto*, para aplicación en un CubeSat.

CubeSat es un estándar de diseño de nanosatélites, cuya estructura es escalable en cubos de 10 cm de arista y masa inferior a 1,33 kg. La premisa de este trabajo se basa en el diseño de un sistema de adquisición y transmisión de datos según el MCU STM32F4-BlackPill y en una estación de recepción de datos y transmisión de comandos según el MCU STM32F429ZI.

Esto es, el proyecto se divide en dos sistemas que trabajan de forma codependiente pero que son controlados por microcontroladores distintos:

 + Uno es el SATDAC (Sistema de Adquisicón y Transmisión de Datos Autosuficiente y Controlable), que estaría ubicado dentro del hipotético CubeSat.
 + Otro es el ERDYTC (Estación de Recepción de Datos Y Transmisión de Comandos), que se encontraría fuera del CubeSat.

El SATDAC posee las siguientes capacidades:

 + Sensado de temperatura.
 + Control y despliegue de periféricos por comando.
 + Recepción y transmisión de datos por RF.

Y la ERDYTC las siguientes:

 + Capacidad para mostrar datos recibidos y estados en LCD.
 + Ingreso de comandos por usuario y transmisión de los mismos.
 + Almacenamiento en memoria externa.
 + Recepción y transmisión de datos por RF.
* SATDAC:

Aquí realizar una descripción más detallada del SATDAC, poner fotos de placas, prototipo físico terminado, etc.

** Librerias utilizadas:

Aquí se muestran las librerías utilizadas en el diseño del sistema.

 + Librería estándar, con las funciones y códigos básicos para microcontroladores STM32F4XX:

#+begin_src C
#include "stm32f4xx.h"
#include "stm32f4xx_gpio.h"
#include "stdio.h"
#include "misc.h"
#+end_src

 + Librería para el control del CLOCK del MCU:

#+begin_src C
#include "stm32f4xx_rcc.h"
#+end_src

 + Librería para el control de pines analógicos:

#+begin_src C
#include "stm32f4xx_adc.h"
#+end_src

 + Librería para el control de TIMERS:

#+begin_src C
#include "stm32f4xx_tim.h"
#+end_src

 + Libería para habilitar funciones matemáticas, como /pow()/:

#+begin_src C
#include "math.h"
#+end_src
** Estructuras:

En esta sección se declaran las diferentes estructuras utilizadas para la configuración de pines del MCU.

*** General:

La siguiente es la estructura para configuración de pines como salidas digitales:

#+begin_src C
GPIO_InitTypeDef    GPIO_InitStructure;
#+end_src

La siguiente es la estructura para la configuración y habilitación de interrupciones (por vencimiento de cuenta de TIMER, por DMA, etc.):

#+begin_src C
NVIC_InitTypeDef    NVIC_InitStructure;
#+end_src

La siguiente estructura se utiliza para configurar interrupciones externas; principalmente utilizada para interrupir según el estado de una entrada digital (pulsador, etc.):

#+begin_src C
EXTI_InitTypeDef   EXTI_InitStructure;
#+end_src

*** ADC:

Se definen las estructuras para inicializar pines como convertores analógico/digital:

#+begin_src C
ADC_InitTypeDef         ADC_InitStructure;
ADC_CommonInitTypeDef   ADC_CommonInitStructure;
#+end_src
*** TIMERS:

Las siguientes estructuras se utilizan en la configuración de TIMERS del MCU:

#+begin_src C
TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
TIM_OCInitTypeDef       TIM_OCInitStructure;
#+end_src

*** DMA:

La siguiente estructura se utiliza en la configuración y habilitación de la funcionalidad de DMA (/Acceso Directo a Memoria/):

#+begin_src C
DMA_InitTypeDef     DMA_InitStructure;
#+end_src

** Definición de constantes:
En esta sección se definen constantes a utilizar en el resto del código.

*** Hardware:

Aquí se definen como constantes los pines que se utilizarán en el hardware.

**** Servomotor:

#+begin_src C
#define _servo  GPIOG
#define servo   GPIO_Pin_3
#+end_src

*** LCD:

Aquí se definen distintas constantes que se utilizan en las funciones de control del LCD:

#+begin_src C
#define  TLCD_INIT_PAUSE        100000
#define  TLCD_PAUSE             50000
#define  TLCD_CLK_PAUSE         1000
#define  TLCD_MAXX              16
#define  TLCD_MAXY              2
#define  MaxDigCount            4095
#define  MaxMiliVoltRef         3320
#define  Res32Bit               32
#define  DAC_DHR12R2_ADDRESS    0x40007414
#define  TLCD_CMD_INIT_DISPLAY  0x28
#define  TLCD_CMD_ENTRY_MODE    0x06
#define  TLCD_CMD_DISP_M0       0x08
#define  TLCD_CMD_DISP_M1       0x0C
#define  TLCD_CMD_DISP_M2       0x0E
#define  TLCD_CMD_DISP_M3       0x0F
#define  TLCD_CMD_CLEAR         0x01
#+end_src

La estructura para identificar los pines del LCD:

#+begin_src C
typedef enum
{
  TLCD_RS = 0,  // RS-Pin
  TLCD_E  = 1,  // E-Pin
  TLCD_D4 = 2,  // DB4-Pin
  TLCD_D5 = 3,  // DB5-Pin
  TLCD_D6 = 4,  // DB6-Pin
  TLCD_D7 = 5   // DB7-Pin
}TLCD_NAME_t;
#+end_src

Se define el nombre del LCD como una constante:

#+begin_src C
#define  TLCD_ANZ   6
#+end_src

Y se crea una estructura con los estados del mismo:

#+begin_src C
typedef enum {
  TLCD_OFF = 0,
  TLCD_ON,
  TLCD_CURSOR,
  TLCD_BLINK
}TLCD_MODE_t;
#+end_src

Finalmente la estructura para crear el objeto LCD (de 2x16 que se utilizará en este caso):

#+begin_src C
typedef struct {
  TLCD_NAME_t TLCD_NAME;
  GPIO_TypeDef* TLCD_PORT;
  const uint16_t TLCD_PIN;
  const uint32_t TLCD_CLK;
  BitAction TLCD_INIT;
}LCD_2X16_t;
#+end_src
*** Servomotor:

Frecuencia del PWM en Hz que controlorá el servomotor:

#+begin_src C
#define freqServo 10e3
#+end_src

** Definición de funciones locales:

En esta sección se definen las distintas funciones a utilizar en el código local.

*** TIMERS:
**** TIM3:
Función para incializar el TIM3 del MCU con una determinada frecuencia.

 + *Returns*: void.
 + *Params* : freq - Frecuencia en /[Hz]/ a la que se inicializará el TIM3.

#+begin_src C
void INIT_TIM3(uint32_t freq);
#+end_src

**** TIM4:

Función para inicializar el TIM4 para el control de la salida PWM necesaria para el control del servomotor:

 + *Returns*: void.
 + *Params* : freqPWM - Frecuencia del PWM a la que se incializará el TIM4.

#+begin_src C
void INIT_TIMPWM(uint32_t freqPWM);
#+end_src

*** Servomotor:

Función para iniciar el proceso de movimiento del servomotor.

 + *Returns*: void.
 + *Params* : void.

#+begin_src C
void MOVE_SERVO(void);
#+end_src

** Main:

#+begin_src C
int main(void)
{
  while (1)
  {
  }
}
#+end_src
** Funciones locales:

En esta sección se implementan las diferentes funciones del código.

*** TIMERS:

**** TIM4:

Este es el TIMER utilizado para el control de la salida PWM.

***** Inicialización:

Aquí se inicializa el TIMER para setear la frecuencia inicial del PWM.

#+begin_src C
void INIT_TIMPWM(uint32_t freqPWM){
TIM_TimeBaseInitTypeDef TIM_BaseStruct;
#+end_src

En principio, se habilita el clock para el TIM4; el cual está conectado al bus APB1.

#+begin_src C
RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
#+end_src

En este caso, como se quiere que la frecuencia del TIM sea la máxima, se setará el prescaler en cero:

#+begin_src C
TIM_BaseStruct.TIM_Prescaler = 0;
#+end_src

Esto es debido a que la frecuencia de tick del TIM está definida como:

 + TIM_tickFreq = TIM_defaultFreq / (prescaller_set + 1)

De esta forma, se garantiza que TIM_tickFreq = TIM_defaultFreq.

Se setea el conteo hacia arriba:

#+begin_src C
TIM_BaseStruct.TIM_CounterMode = TIM_CounterMode_Up;
#+end_src

Ahora, para setear el periodo del TIM cuando se resetea, primero se debe obtener el valor máximo para el timer. En este caso, como el TIM es de 16 bits, el valor máximo será 2^16 = 65535.

Para obtener la frecuencia del PWM, la ecuación es:

 + PWM_freq = TIM_tickFreq / (TIM_period + 1)
 + TIM_period = TIM_tickFreq / PWM_freq - 1

Se obtiene un periodo entonces según:

#+begin_src C
TIM_BaseStruct.TIM_Period = SystemCoreClock / freqPWM - 1;
#+end_src

Y se terminan de inicializar los restantes parámetros del timer:

#+begin_src C
TIM_BaseStruct.TIM_ClockDivision = TIM_CKD_DIV1;
TIM_BaseStruct.TIM_RepetitionCounter = 0;
#+end_src

Finalmente, se carga la inicialización en la estructura del timer y se comienza el conteo:

#+begin_src C
TIM_TimeBaseInit(TIM4, &TIM_BaseStruct);
TIM_Cmd(TIM4, ENABLE);
}
#+end_src
